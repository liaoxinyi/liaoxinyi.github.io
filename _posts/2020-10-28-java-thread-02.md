---
layout:     post
title:      "怎么都在谈高并发-02"
subtitle:   "Java内存模型、synchronized、volatile、线程安全"
date:       2020-10-28
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-thread-bg.jpg"
tags:
    - Java
---
> Java多线程编程核心技术-高宏岩2015版-读书笔记

### 前言
&emsp;&emsp;前面主要回顾了一下线程的基础知识，包括线程的生命周期，线程是如何创建、停止以及暂停的。都在说高并发，肯定离不开“同步”二字，这就涉及到对象以及变量的并发访问。具体来说，就是在多个线程同时访问对象及其变量的时候，数据会不会出现“脏读”
### Java内存模型
&emsp;&emsp;说道线程，肯定与内存模型分不开关系，这里回顾一下之前在JVM中初步了解的Java内存模型。Java内存模型和JVM中讲到的各种区域划分是在不同的层次，二者没有任何关系。引用书中的话：  
>从变量、主内存、工作内存的定义来看：主内存王要对应于Java堆中的对象实例的数据部分，而工作内存则对应于虚拟机栈中的部分区域。从硬件角度看，主内存就直接对应于物理硬件的内存，而为了获取史好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行的时候主要访问的是工作内存。-----深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)-读书笔记

&emsp;&emsp;Java的内存模型其实可以看成是一种规则，这个规则定义了虚拟机将变量存入内存，从内存取出的种种细节。当然，这个时候的变量就不是Java代码里面的那种变量了，而是包括了静态字段、实例字段和构成数组对象的元素  
##### 主内存（Main Memory）
可以理解为硬件中的主内存，二者起到的作用也是一致的  
##### 工作内存（Working Memory）
&emsp;&emsp;**属于每条线程自己单独拥有，不同线程彼此之间也是没法访问对方工作内存里面的东西的**，里面存放了该线程使用到的变量在主内存中的副本拷贝。这里就有点意思了，以前我以为线程会把访问的整个对象全部拷贝过来。其实想想根本不可能的，那样的话内存早就炸了，真实情况是，拷贝的东西往往是对象的引用，或者对象中的某个字段。线程对变量的所有操作（读取、赋值等）都只能是在工作内存中，完了之后在写入主内存中  
&emsp;&emsp;**<font color=red>其实volatile修饰的变量也是在工作内存中有副本的，所以在各个线程的工作内存中，volatile变量也是可能存在互不相同的时候。只不过volatile变量在每次使用之前都会先刷新，也就是说对于执行引擎而言是看不到刷新前的不一致现象的。这样的操作顺序很特殊，让volatile变量看起来就像是在直接操作主内存一样</font>**  

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/20201015170357.png)
<center>线程、主内存、工作内存三者关系图</center>
- 内存间的交互操作
1. **lock、unlock、read、load、use、assign、store、write，8个操作具有原子性（除开64位的数据类型：long和double需要划分两次32的操作外）**  
2. read和load区别：前者作用于主内存，将变量值从主内存中取出；后者作用于工作内存，将read读出的变量值放入工作内存的变量副本中  
3. use和assign的区别：前者把变量值传递给执行引擎，后者把一个从执行引擎接收到的值赋给工作内存变量  
4. store和write区别：前者将工作内存变量传输到主内存，后者作用对象是主内存中的变量  
结合JVM的运行时数据区域，虚拟机栈是属于线程私有的，所以方法内部的私有变量可以视为线程安全的，而涉及类成员变量的操作是线程不安全的

### synchronized
##### 同步方法
- 锁对象
**synchronized取得的锁都是对象锁**  
两个线程访问同一个对象的两个同步方法时：  
1. A线程在最先调用Object对象的synchronized方法时，先获得object对象的Lock锁，B线程可以异步的方式调用object对象中的非synchronized类型的方法  
2. A线程先持有object对象的Lock锁，B线程需要调用object对象中的synchronized类型的方法时需要等待，也就是同步，**不管此时B线程是不是要调用A线程的那个方法**
- 锁重入
锁重入的意思就是，当一个线程得到一个对象锁后，再次清求此对象锁时是可以再次得到该对象的锁的。直观表现就是synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。虽然感觉这个线程有点嚣张，但是仔细想想，如果没有这个设定，那直接就造成死锁了  
**当存在父子类继承关系时，子类可以通过“可重入锁”调用父类的同步方法**  
- 锁释放
**当一个线程执行的代码出现异常时，其所持有的锁会自动释放**
- 继承
**同步不可继承**  
同步不具有继承性，如果父类具有一个同步方法，子类继承后，同名方法不再具有同步性  

##### 同步语句块
之所以出现同步语句块，是因为如果只有同步方法而这个方法中其实只有部分内容需要同步且执行时间又很长，其他线程就会等待很长时间了，所以同步语句块应运而生  
一般是用对象的this作为锁，如果使用非this对象，可以在一定程度上提高运行效率（前提是原来的对象中同步方法很多）：
```java
synchronized(this){
}
```
- 锁对象：**同步代码块的锁对象也是当前对象**

##### 静态同步
相当于对当前.java文件对应的Class文件进行持锁，Class锁可以对类的所有对象实例起作用
##### 字符串同步
```java
synchronized("XXX"){
}
```
一般都不把字符串作为锁，因为字符串在字符常量池中的地址是一样的，所以容易造成很多线程都去等待同一把锁  
##### 锁对象的改变
只要对象不变，即使对象的属性被改变，锁依然不改变
### volatile
##### 特点
- 保证此变量对所有线程是立即可见的
- 禁止指令重排序优化，保证代码的执行顺序与程序的执行顺序一致
- 注意：  
1. 即使编译出来只有一条字节码指令，也并不意味着这条指令就是一个原子操作  
2. 不具备同步性也不具备原子性，需要使用加锁来保证原子性  
3. long和double型变量的特殊规则  
4. volatile修饰的变量也是在工作内存中有副本

##### 详细分析
假设有线程T和volatile变量V和volatile变量W，那么在进行read、load、use、assign、store、write的时候会有如下的规则：  
1. 同一个线程操作同一个变量时，use的前一个动作必须是load，同时只有在马上要use的时候才能进行load（这就保证了每次使用变量前，都能从主内存得到最新的值）  
2. 同一个线程操作同一个变量时，store的前一个动作必须是assign，同时只有在马上要store的时候才能进行assign（这就保证了每次变量一更改，主内存马上就能得到更新）  
3. 假设动作A是线程T对变量V实施的use或者assign，假设动作F是和A相关的load或者store，假设动作P是和F相关的read或者write；假设动作B是线程T对变量W实施的use或者assign，假设动作G是和B相关的load或者store，假设动作Q是和G相关的read或者write；那么，如果A先于B，则P先于Q（也就是此时不会出现指令重排序，代码的执行顺序与程序的执行顺序一致）

##### volatile和synchronized对比
1. 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰变量，而synchronized可以修饰方法和代码块。之前一直说尽量少用synchronized修饰方法，但是现在新版的Java之后，这个效率得到了很大程度提升  
2. 多线程访问volatile不会发生阻塞、而synchronized会出现阻塞  
3. volatile能保证数据的可见性，但**不能保证原子性**；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数锯做同步  
4. volatile解决的是变量在多个线程之间的访问性，synchronized解决的是多个线程之间访问资源的同步性

### 线程安全
线程安全主要是围绕原子性、可见性和有序性来进行讨论的
##### 原子性（Atomicity）
- volatile的非原子性
为啥线程安全要讨论原子性，那上面的volatile关键字来说明。不要以为volatile修饰一个变量后，涉及到这个变量的所有操作就都是线程安全的了，以`i++`为例（本质是`i=i+1`），这个操作其实不是原子的，分为三步：  
1. 从内存取出i  
2. 计算i=i+1  
3. 将i的值写到内存中  
如果在第二步的时候，被其他线程修改了i，这个时候就出现了脏数据。所以，volatile不是万能的，主要是为了解决对数据操作是否及时影响到主内存中，这里有必要结合线程的工作内存和主内存详细研究一下volatile的工作情况：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-thread-volatile.jpg)
<center>变量在内存中的工作过程</center>
在多线程环境中，use和assign是多次出现的，但这一操作并不是原子性，也就是在read和load之后，如果主内存的count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，此时私有内存和公共内存中的变量就不一致了。如果此时有另外的线程来读取count变量，期望得到的是计算之后的（也就是此时私有内存的值）但实际得到是主内存的值，这就出现了非线程安全问题  
结合上面的工作过程，volatile主要保证的是不同线程在针对同一个变量的read和load操作时发现主内存中count的值都是一个最新的值，那么都会加载这个最新的值  
- 原子类也不是完全安全  
原子类是原子操作可用的类型，原子操作是不可分割的，没有其他线程能够中断或者检查原子操作中的变量。所以，原子类的确很拽，但是也不是说就完全安全（世上没有绝对安全的防御）。因为原子类虽然的赋值和取值是原子性的，能够保证数据在每次操作中都是最新的，但是因为操作原子类的不同方法却不是原子的，所以**原子类在具有逻辑性的情况下所输出的结果具有随机性**  

##### 可见性（Visibility）
指当一个线程修改了共享变量的值，其他线程能够马上得知这个修改（**volatile**、**synchronized**和**final**）
- volatile的可见性（不用再赘述了，上面记录了）
- synchronized的可见性  
这个可见性的原理是因为同步块中，在对一个变量执行unlock之前，需要把这个变量先同步回主内存之中，所以这样保证了可见性  
- final的可见性
这个毋庸置疑了，从之前JVM中的知识也可以知道，final修饰后进入了常量池

##### 有序性（Ordering）
这个如果从字面上理解有序其实只包含了一个视角，也就是本线程内的视角。在本线程内观察，所有的操作都是有序的，而在一个线程中观察另外一个线程，所有的操作都是无序的。总结起来就是，**线程内串行，线程间指令重排序**。当然，volatile和万能的synchronized关键字都可以保证有序性的
##### 先行发生原则（happens-before）
字面上说，两次操作先行发生的原则就是先后的关系。但在Java中，更多的是指先行发生的操作后，对应产生的影响（修改了内存中共享变量的值、发送了消息、调用了方法等）都能被后面的操作所感知到。**如果有两个或者多个操作不再此列，并且无法从先行发生规则推导出来的话，它们就没有顺序性保障，虚拟机可以对他们进行随意的重排序**  
- 程序次序规则（Program Order Rule）  
这个不是单纯意义上的代码编写的顺序，因为代码中还有分支、循环等，所以这里应该是说的控制流顺序，也就是说在一个线程内是按照控制流顺序执行的  
- 管程锁定规则（Monitor Lock Rule）  
对于同一个锁而言（同一锁的要求很重要），unlock操作先行发生于接下来对这个锁的lock操作  
- volatile变量规则（Volatile Variable Rule）  
对同一个volatile变量的写操作，先行发生与接下来对这个变量的读操作  
- 线程启动规则（Thread Start Rule）  
Thread对象的start方法先行发生于此线程的每一个动作（这个不难理解，start都不开始咋搞）  
- 线程终止规则（Thread Termination Rule）  
线程中的所有操作都先行发生于对此线程的终止检测  
- 线程中断规则（Thread Interruption Rule）  
对线程interrupt()方法的调用先行发生于对中断线程的代码检测（比如Thread.interrupted()）  
- 对象终结规则（Finalizer Rule）  
一个对象的初始化完成（构造函数执行结束，这点不同于类加载过程中的对象初始化），先行发生于它的finalize()  
- 传递性（Transitivity）  
如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C  

&emsp;&emsp;这里有一个很有意思的现象：**一个操作在运行层面上是比另外一个操作先发生的，不一定代表这个操作就是先行发生于另外那个操作，同理一个操作先行发生于另一个操作，也无法推导出它在运行时就一定会先发生（指令重排序）**  
&emsp;&emsp;**<font color=red>归根结底，并发安全，其实不要仅仅局限于并发操作的时间先后，更多的应该从先行发生原则来进行对比</font>**  

JVM-12.4-java与线程









