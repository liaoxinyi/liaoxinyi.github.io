---
layout:     post
title:      "细嚼慢咽JVM-02"
subtitle:   "OutOfMemoryError、垃圾收集器、内存分配策略"
date:       2020-10-12 23:59:00
author:     "ThreeJin"
header-img: "https://i.loli.net/2020/09/23/cpdwJsZi93e8LNB.png"
tags:
    - Java
---
> 深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)-读书笔记。

### 前言
&emsp;&emsp;在前面了解了Java虚拟机的运行时数据区域构成和对象创建的过程，接下来学习一下老生常谈的OOM、垃圾收集器以及内存分配策略。
### OOM
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)
<center>运行时数据区域</center>
##### Java堆溢出
- **原因一：内存泄漏（Memory Leak）**
指程序在申请内存后，无法释放已申请的内存空间，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。换句话，就是说存在很多个对象在GC分析可达性后到GC Roots一直存在引用链，无法被回收器回收，可以理解为这些对象是“尸位素餐”。
- **原因二：内存溢出（Memory Overflow）**
最为常见的OOM原因，当无法申请到足够的内存时，抛出内存溢出

##### 虚拟机栈和本地方法栈溢出
- 一些说明
&emsp;&emsp;通过书中前面的内容，在栈里面会出现两种异常（StackOverflowError和OutOfMemoryError），分别对应着请求栈深度太大时的异常与虚拟机扩展栈时内存不够的异常。但是实际在测试过程中，发现后者很难复现。即使模拟出现后者，也不知道是因为此时内存不足是不是因为虚拟机栈扩展导致的。
- 解决方法
&emsp;&emsp;一般来说，采用虚拟机默认的栈深度（1000~2000）时，是没有问题，但是当在多线程条件下的时候，容易导致虚拟机栈出现OOM。这个时候，如果没法减少线程数，也没法升级硬件的时候，**只有通过设定参数减小最大堆以及减小栈容量**（个人理解的是每个方法压入栈的帧大小）来换取更多线程了

##### 方法区和运行时常量池溢出
&emsp;&emsp;运行时常量池就在方法区中，所以一般两个的异常是一起的。比如程序产生了大量的无法被回收的类后，会造成方法区的溢出（比如cglib的动态反射技术如果不注意类回收的话就容易发生这种情况，又或者是同一个类被很多不同的类加载器加载后也会生成不同的类，再比如大量的jsp文件在第一次运行的时候被编译成了大量的java类）

##### 直接内存溢出
- 默认与java堆大小一致，可以通过**-XX:MaxDirectMemorySize**设定
- 直接内存导致的内存溢出一个明显的特征是在Heap Dump文件中不会看见明显的异常，且一般dump文件比较小。如果遇到这种情况，项目中又有使用了NIO的话，可以考虑是直接内存溢出了

### 垃圾收集器

#### 总结
- Java虚拟机的运行时数据区域：程序计数器、Java虚拟机栈、本地方法栈、方法区、Java堆
- 除了程序计数器外，其他运行时数据区域都可能会发生OOM
- 三种常量池和直接内存
- 对象的创建（只是创建，还没涉及到初始化）和访问