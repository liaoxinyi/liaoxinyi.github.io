---
layout:     post
title:      "细嚼慢咽JVM-02"
subtitle:   "OutOfMemoryError、垃圾收集器、内存分配策略"
date:       2020-10-12 23:59:00
author:     "ThreeJin"
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/article-head.png"
tags:
    - Java
---
> 深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)-读书笔记。

### 前言
&emsp;&emsp;在前面了解了Java虚拟机的运行时数据区域构成和对象创建的过程，接下来学习一下老生常谈的OOM、垃圾收集器以及内存分配策略。
### OOM
##### Java堆溢出
- **原因一：内存泄漏（Memory Leak）**  
&emsp;&emsp;指程序在申请内存后，无法释放已申请的内存空间，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。换句话，就是说存在很多个对象在GC分析可达性后到GC Roots一直存在引用链，无法被回收器回收，可以理解为这些对象是“尸位素餐”。
- **原因二：内存溢出（Memory Overflow）**  
&emsp;最为常见的OOM原因，当无法申请到足够的内存时，抛出内存溢出

##### 虚拟机栈和本地方法栈溢出
- 一些说明  
&emsp;&emsp;通过书中前面的内容，在栈里面会出现两种异常（StackOverflowError和OutOfMemoryError），分别对应着请求栈深度太大时的异常与虚拟机扩展栈时内存不够的异常。但是实际在测试过程中，发现后者很难复现。即使模拟出现后者，也不知道是因为此时内存不足是不是因为虚拟机栈扩展导致的。
- 解决方法  
&emsp;&emsp;一般来说，采用虚拟机默认的栈深度（1000~2000）时，是没有问题，但是当在多线程条件下的时候，容易导致虚拟机栈出现OOM。这个时候，如果没法减少线程数，也没法升级硬件的时候，**只有通过设定参数减小最大堆以及减小栈容量**（个人理解的是每个方法压入栈的帧大小）来换取更多线程了

##### 方法区和运行时常量池溢出
&emsp;&emsp;运行时常量池就在方法区中，所以一般两个的异常是一起的。比如程序产生了大量的无法被回收的类后，会造成方法区的溢出（比如cglib的动态反射技术如果不注意类回收的话就容易发生这种情况，又或者是同一个类被很多不同的类加载器加载后也会生成不同的类，再比如大量的jsp文件在第一次运行的时候被编译成了大量的java类）

##### 直接内存溢出
- 默认与java堆大小一致，可以通过**-XX:MaxDirectMemorySize**设定
- 特征  
&emsp;&emsp;直接内存导致的内存溢出一个明显的特征是在Heap Dump文件中不会看见明显的异常，且一般dump文件比较小。如果遇到这种情况，项目中又有使用了NIO的话，可以考虑是直接内存溢出了

### Java堆和方法区的回收
&emsp;&emsp;因为程序计数器、Java虚拟机栈和本地方法栈这三个的生命周期是跟随线程的，而且栈中每一个栈帧分配多少内存是在类结构确定的时候就已经定下来了（不要忘了在运行期的时候JIT编译期会针对这个进行一些优化），所以以上三个区域的内存回收基本上是板上钉钉的事情，因为方法结束或者线程结束的时候，内存就被回收了。比较难的是Java堆和方法区的内存回收，这也是GC活动的主要重点区域。
##### Java堆中的回收
&emsp;&emsp;Java堆中主要都是各种类的实例对象，判定一个对象是否能被视为回收对象（可以看做被判刑为死缓），方法有引用计数法和可达性分析法
- **死缓方法一：引用计数法**（主流Java虚拟机并未采用该方法）  
&emsp;&emsp;这种方法里面为每一个对象添加了一个引用计数器，每有一个地方引用这个类的时候，计数器就+1，每有一个引用失效的时候，计数器-1。如果任何时刻一个对象的引用计数器都为0，那么这个对象就GG了。弊端：**难以解决对象循环引用的问题，比如两个对象其实已经不会再被访问但它们彼此相互引用，这时它俩是不会被回收的**
- **死缓方法二：可达性分析法**（主流商用程序语言的方法）  
&emsp;&emsp;这种方法的思路是，将一系列被称为GC Roots的对象视为起始节点，往下搜索，走过的路径为引用链（Reference Chain），如果一个对象到GC Roots没有任何引用链，则这个对象就会被视为是可回收的（此时并不代表这个对象一定会被回收）  
&emsp;&emsp;可作为GC Roots对象的有：1.栈帧中本地变量表所引用的对象  2.方法区中类静态属性引用的对象  3.方法区中常量引用的对象 4.本地方法栈中Native方法所引用的对象
- 对象的引用具体是什么  
&emsp;&emsp;我所理解的对象引用是一个reference类型的数据中储存着这个对象对应真实内存的起始地址。其实在java中，对象的引用分为了很多种类型，目的是为了给GC活动提供多选择的回收方案。  
1. 强引用：一般是new出来的对象，只要这种引用在，被引用的对象绝对不会被回收  
2. 软引用：将要内存溢出的时候，才会对这些对象进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出的异常，通过**SoftReference**实现  
3. 弱引用：每次回收都会被收走，通过**WeakReference**实现  
4. 虚引用：不对生存时间造成影响，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到系统通知，可以通过**PhantomReference**实现  
- **死缓到死刑**  
&emsp;&emsp;这里只讨论可达性分析算法的死缓到死刑过程，其中要经历**两次标记和一次筛选过程**  
1. 第一次标记  
&emsp;&emsp;如果这个对象在进行可达性分析后发现与GC Roots没有了引用链，则会被第一次标记，紧接着开始进行一次筛选
2. 一次筛选  
&emsp;&emsp;筛选的条件是这个对象是否有必要执行finalize()方法，当对象没有覆盖finalize方法或者finalize方法已经被虚拟机调用过，这个时候都是没必要执行finalize方法的。反之，一旦判断出有必要执行finalize方法后，对象就会被放入F-Queue队列之中，稍后由一个虚拟机自动建立、低优先级别的Finalizer线程去**异步执行**这个finalize方法（之所以用异步，是因为如果在finalize方法中死循环了，那么F-Queue队列中的其他对象只有永远等待了）  
3. 第二次标记（在F-Queue队列中进行标记）  
&emsp;&emsp;Finalizer线程异步执行finalize之后，过一会儿GC会对F-Queue队列中对象进行第二次小规模的标记，标记的过程也是通过分析与GC Roots的引用链可达与否。所以，finalize方法可以说是对象在死缓过程中的救命稻草（有点像现实生活中的“可操作地带”），因为只要对象在finalize方法中重新与引用链上任何一个其他对象建立关联（比如把自己this赋值给某个类变量或者对象的成员变量）就能够成功拯救自己，这个时候GC就会把这个对象从F-Queue队列中移除。<font color=red>**一个对象的finalize方法最多只会被系统自动调用一次，也就是说finalize这道免死金牌只能使用一次**</font>  
&emsp;&emsp;到了这里，对象如果还没有逃脱了，那就只去阴曹地府了。这里需要说明，书的作者其实不是很推荐使用这种免死金牌的方式来拯救对象，因为运行代价高昂，不确定也比较大。对比之下，常用的try-finally就已经能够满足了。

##### 方法区中的回收
- 回收内容一：废弃常量  
&emsp;&emsp;与java堆中回收对象的引用计数流程类似，只要没有其他地方引用了这些字面量/符号引用，都会被GC回收掉
- 回收内容二：无用的类  
&emsp;&emsp;判断一个类是不是无用的类时，需要同时满足下面三个条件  
1. 该类所有的实例都已经被回收，也即Java堆中不存在该类的任何实例
2. 加载该类的ClassLoader已被回收
3. 该类对应的iava.lang.Class对象没有在任何地力被引用。无法在任何地力通过反射访问该类的方法  
&emsp;&emsp;判断出来类是不是无用的类后，也不是就一定会被回收，这一点与对象不一样，对象如果“死掉了”是必然被回收，而类是否会被回收还需要看虚拟机的类回收参数设置（比如**-Xnoclassgc**等）  

### 垃圾收集算法
##### 标记-清除（Mark-Sweep）
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/mark-sweep.png)
<center>标记-清除算法示意图</center>
- 标记和清除的效率不高
- 标记和清除后产生大量不连续内存碎片，这样导致如果后续需要分配大内存时候找不到足够的连续内存会再次触发另外一次垃圾收集

##### 复制（Copying）
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/copying.png)
<center>复制算法示意图</center>
- 默认Eden和Survivor的比例是8:1
- 如果对象存活率较高时候需要较多的复制操作，效率低
- 浪费了一定担保空间，对于老年代来说一般无用

##### 标记-整理（Mark-Compact）
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/mark-compact.png)
<center>标记-整理算法示意图</center>
&emsp;&emsp;标记之后后续步骤不是直接清理可回收对象，而是让所有存活的对象都向一端移动，然后清理掉边界以外的内存
##### 分代收集（Mark-Sweep）
&emsp;&emsp;根据对象存活周期将内存划分为几块，一般把java堆分为新生代和老年代，前者因为少量存活，所以可以采用复制算法；后者存活率较高，可以使用标记-清理，标记-整理

### 垃圾收集器
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/20201013101302.png)
<center>垃圾收集器总览图</center>
##### Serial收集器
- 最基本、发展最悠久；虚拟机后台自动发起自动完成单线程收集垃圾，期间暂停其他所有工作线程
- 与其他收集器的单线程相比简单高效
- Client模式下的虚拟机新生代默认收集器，因为用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大

##### ParNew收集器
- Serial收集器的多线程版本，但是在单CPU条件下比不上Serial
- Server模式下的首选新生代收集器
- 仅它可以与CMS收集器配合工作

##### Parallel Scavenge收集器
- 新生代收集器，使用的复制算法，并行的多线程收集器
- 特点在于它的关注点在于达到一个可控制的吞吐量（运行用户代码的时间/运行和垃圾收集的总时间）
- 具有GC自适应调整策略
- 适用于在后台运算而不需要太多交互的任务

##### Serial Old收集器
- Serial收集的老年代版本，单线程收集器，使用标记-整理算法
- 主要在Client模式下使用
- Server模式下与Parallel Scavenge收集器搭配使用或者作为CMS收集器的后备预案

##### Parallel Old收集器
&emsp;&emsp;Parallel Scavenge收集器的老年代版本，多线程收集器，使用标记-整理算法
##### CMS收集器
- 以最短回收停顿时间为目标的收集器，基于标记-清除算法实现
- 过程  
1. 初始标记：需暂停其他线程，标记一下GC Root能够直接关联到的对象
2. 并发标记：进行GC Tracing，耗时较长
3. 重新标记：修正并发标记期间标记发生变动的那一部分对象的标记记录，需暂停其他线程，但可并行执行
4. 并发清除：耗时最长  
- 内存回收的过程是与用户线程一起并发执行的
- 优点和缺点  
1. 并发收集、低停顿
2. 对CPU资源非常敏感，默认启动的回收线程数=（CPU个数+3）/4，少CPU条件下运行效率低
3. 无法处理浮动垃圾
4. 因为是标记-清除算法，所以收集结束后会有大量的空间碎片产生

##### G1收集器
- 面向服务端应用的垃圾收集器
- 过程  
1. 初始标记
2. 并发标记
3. 重新标记
4. 筛选回收：首先对回收价值排序，再根据用户期望的GC时间来制定回收计划  
- 优点和缺点  
1. 并行和并发：充分利用多CPU、多核环境下的硬件优势
2. 分代收集：不需要与其他收集器配合就能独立管理整个GC堆
3. 空间整合：有点像是融合了复制+标记清除算法，所以不产生内存空间碎片
4. 可预测的停顿：以最短回收停顿为目标，同时建有可预测停顿时间模型，可指定时间片段让消耗在垃圾收集上的时间不超过它，底层是通过跟踪各个Region里的垃圾堆积价值大小然后加入优先列表，再根据价值由大到小挨个回收
5. 如果追求吞吐量的话，其实G1并不适合

### GC日志
- 最前面的数字代表GC发生的时间，从java虚拟机启动以来经过的秒数
- [GC]和[Full GC]说明垃圾收集的停顿类型，后者说明此次收集暂停了其他线程
- 接下来是表示GC发生的区域
- GC前后该内存区域已经使用的容量
- 该内存区域GC所占用的时间，单位秒 

### 内存分配与回收策略
- 对象优先在新生代的Eden分配，若该区没有空间，发起一次MinorGC（发生在新生代的GC对应有MajorGC则在老年代）
- 大对象直接进入老年代，比如很长的字符串以及数组
- 长期存活的对象将进入老年代，对应有Age计数器
- 动态对象年龄判定
- 空间分配担保  
>&emsp;&emsp; 发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC 可以确保足安全的。如果不成立，则虚拟机会查看HandIePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小丁，或者HandIePromotionFailure设置不允许冒险，那此时改为Full GC。
----《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》

### 总结
- OutOfMemoryError：Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、直接内存溢出
-  Java堆和方法区的回收：对象的死缓到死刑、对象引用是什么、废弃常量和无用的类
-  垃圾回收算法和垃圾回收器
-  GC日志、内存分配与回收策略