---
layout:     post
title:      "又见MySQL-01"
subtitle:   "MVCC、几种读"
date:       2021-04-05
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-bk.png"
tags:
    - MySQL

---
> 资料来源于网络上各位前辈（慧鑫coming、爱情小傻蛋等）

### 前言
毕业之后，由于工作的原因，一直是在跟pg数据库打交道，对于MySQL的认知还停留在以前学校做项目的时候。那个时候，受到项目级别的限制，基本上就是比较简单的CRUD和一些基本的事务常识，涉及到并发控制、索引等知识的时候，往往没有细究。所以这里新开一个篇章，用来整理一些之前没有认真去研究的东西。

### 数据库的并发场景
- 读-读

不存在任何问题，也不需要并发控制

- 读-写

有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

- 写-写

有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

既然要解决并发场景带来的问题，那么自然就引出了MySQL下的MVCC

### MVCC（Multi-Version Concurrency Control）
即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读  

现在大体上可以有如下的解决策略：

- MVCC + 悲观锁

MVCC解决读写冲突，悲观锁解决写写冲突

- MVCC + 乐观锁

MVCC解决读写冲突，乐观锁解决写写冲突

这些组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题

##### 当前读和快照读
在理解MVCC的时候，往往是离不开这两种读的。说实话，以前只知道有这两种的区别，但是没有真正去细分MySQL InnoDB下的当前读和快照读  
- 当前读

像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

- 快照读

像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。**换句话说，MVCC可以理解为一种为了保证读写操作没有冲突的概念方法，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现**

所以，在快照读中，需要了解一下底层的实现，这里涉及到3个隐式字段、undo日志以及Read View

##### 3个隐式字段
每行记录除了我们自定义的字段外，还有数据库隐式定义的**DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID**等字段

- DB_TRX_ID

6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID，**当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大**

- DB_ROLL_PTR

7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）

- DB_ROW_ID

6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引

- 实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/MySQL-mvcc-01.jpg)  

如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本

##### undo日志
**当事务要对数据库某一行数据进行操作的时候，数据库会先对该行加排他锁。然后把该行数据拷贝到undo log中，拷贝完毕后，再修改数据库该行对应的信息，修改隐藏字段的事务ID为当前事务的ID,同时回滚指针指向拷贝到undo log的副本记录，等到事务提交后，释放锁**

undo日志包含两种日志，**insert undo log和update undo log**

- insert undo log

代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃

- update undo log

事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除

purge的详细说明：

从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。

为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。

**不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录，往往最先被purge线程清除掉**，比如insert undo log，其实在事务提交之后很可能就已经被删除丢失了

##### Read View

- 是什么？

Read View就是事务进行**快照读操作**的时候生产的读视图

- 用来干什么？

Read View主要是用来做可见性判断的, 即当某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断（**会去调用可见性算法，即changes_visible方法**）当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据

- 有什么？

Read View简单的理解成有三个全局属性：

    - list：一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID
    
    - up_limit_id：记录列表中事务ID最小的ID
    
    - low_limit_id：ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1
    
- 可见性算法是怎么判断的？

    - 首先比较DB_TRX_ID < up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断
    
    - 接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断
    
    - 判断DB_TRX_ID 是否在活跃事务之中，list.contains(DB_TRX_ID)，如果在，则代表这个Read View生成时刻，DB_TRX_ID这个事务还在活跃，还没有Commit，它修改的数据，当前事务也是看不见的；如果不在，则说明，DB_TRX_ID这个事务在Read View生成之前就已经Commit了，它修改的结果，当前事务是能看见的
    
- 不可见之后怎么办呢？

**如果最近这一条记录事务id不符合条件，不可见的话，再去undo日志的记录链里面找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束**
    
##### 模拟分析
知道了这三个特性（隐式字段、undo日志、read view）后，通过模拟来看MVCC是怎么实现的。

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/mysql-mvcc-02.jpg)  

当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表list上，此时事务2的read view为

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/mysql-mvcc-03.jpg)  

此时事务2的undo日志如下：

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/mysql-mvcc-04.jpg)  

先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本

总的来说，流程可以概括如下：

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/mysql-mvcc-05.jpg)  

##### 结论

**正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同**

- 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见

- 而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因

**总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View**

### 几种读
##### 脏读
相当于是没有事务的隔离，脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
##### 不可重复读
不可重复读是指在事务1内，读取了一个数据，事务1还没有结束时，事务2也访问了这个数据，修改了这个数据，并提交。紧接着，事务1又读这个数据。由于事务2的修改，那么事务1两次读到的的数据可能是不一样的，因此称为是不可重复读。

可以将事务的隔离级别设置为可重复读，就能避免该问题，但是幻读的情况依然有。
##### 幻读
- 前提条件：InnoDB引擎，可重复读隔离级别，使用当前读时。

- 表现

一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。两点需要说明：

    1. 在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。
    
    2. 幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。
    
- 特点

**不可重复读重点在于update和delete，而幻读的重点在于insert，不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影**

- 产生的原因

行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。

- 影响

1. 会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。

2. 产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。

- 如何解决？

1. 将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为间隙锁（next-key locking）。间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是往这个间隙中插入一个记录这个操作。

或者，通过对 select 操作手动加 行X锁（SELECT ... FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会悄悄做的事情），同时还需要知道，即便当前记录不存在，比如 id=1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock），其他事务则无法插入此索引的记录，故杜绝了幻读。

举个例子：  
`SELECT `id` FROM `users` WHERE `id` = 1 FOR UPDATE;`

如果 id = 1 的记录存在则会被加行（X）锁，如果不存在，则会加 next-lock key / gap 锁（范围行锁），即记录存在与否，mysql 都会对记录应该对应的索引加锁，其他事务是无法再获得做操作的。**InnoDB 的行锁（gap锁是范围行锁，一样的）锁定的是记录所对应的索引，且聚簇索引同记录是直接关系在一起的。**

2. 或者更改隔离级别为串行化，但是这往往是很低效的处理方式

##### 总结
RR 级别作为 mysql 事务默认隔离级别，是事务安全与性能的折中，可能也符合二八定律（20%的事务存在幻读的可能，80%的事务没有幻读的风险），我们在正确认识幻读后，便可以根据场景灵活的防止幻读的发生。

SERIALIZABLE 级别则是悲观的认为幻读时刻都会发生，故会自动的隐式的对事务所需资源加排它锁，其他事务访问此资源会被阻塞等待，故事务是安全的，但需要认真考虑性能。

InnoDB 的行锁锁定的是索引，而不是记录本身，这一点也需要有清晰的认识，故某索引相同的记录都会被加锁，会造成索引竞争，这就需要我们严格设计业务 sql，尽可能的使用主键或唯一索引对记录加锁。索引映射的记录如果存在，加行锁，如果不存在，则会加 next-key lock / gap 锁 / 间隙锁，故 InnoDB 可以实现事务对某记录的预先占用，如果记录存在，它就是本事务的，如果记录不存在，那它也将是本事务的，只要本事务还在，其他事务就别想占有它。


