---
layout:     post
title:      "可不敢吹自己会Redis-01"
subtitle:   "Redis基础、常用数据结构和命令、为什么Redis很快、缓存穿透和缓存雪崩、Redis的瞬间卡顿"
date:       2021-04-02
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-bk.png"
tags:
    - Java
    - Redis

---
> 资料来源于网络上各位前辈（XXX）

### 前言
留下的坑，终究还是要来填的。之前一直计划着要把在项目里面使用Redis的一些踩坑记录一下，今天终于有时间来沉淀了。话不多说，直接开搞。
### redis 简介
简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以存写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁（这个目前在项目中还没有玩儿过）。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案
### 为啥要用Redis？
- 高性能和分担压力  
那必须是高性能，操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。其次就是在高并发的时候可以分担数据库压力。  
- 为什么要用 redis 而不用 map/guava 做缓存?  
缓存分为本地缓存和分布式缓存。以 Java 为例，使用map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束。所以，在多实例的情况下，每个实例都是各自保存一份缓存，缓存不一致，或者说要做到缓存一致的话耗费的资源比较大。  
redis 或 memcached 可以做到分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。  
- redis 和 memcached 的区别  
    - redis支持更丰富的数据类型：String，list，hash，set，zset  
    - memcache支持简单的数据类型，String  
    - redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中  
    - memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的  
    - memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型  
    
    ![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-01-01.jpg)  
    
### 常见数据结构
谈到Redis的数据结构，其实是指value的的类型，在这之前，先说一下redis的key  
##### key
redis的key 值是字符串储存的，这意味着可以用任何文本作为key值，从形如”foo”的简单字符串到一个JPEG文件的内容都可以  
**空字符串也是有效key值**  
键值不需要太长，首先消耗内存过多，其次键值计算成本较高（查询耗时长）  
key的几个命令：set、del、get、mget、exists、**incr**、**decr**、expire、type等，注意`OBJECT ENCODING key `可以查看底层的数据结构  
redis每创建一个key，都会为这个键储存一些附加的管理信息（比如这个键的类型，这个键最后一次被访问的时间等等），因此redis的key相对于值来说更珍贵  
reids数据库中的key越多，redis数据库服务器在储存附加管理信息方面耗费的内存就越多，在获取key对应的value值时cpu的开销也会更多  

##### String

- 常用命令: set,get,decr,incr,mget 等  
- value其实不仅可以是String，也可以是数字  
- **底层存储结构**：简单动态字符串SDS（simple dynamic string）  
    - 规定字符串的长度不超过512M字节  
    - 相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数  
- **底层存储方式**   
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-01-02.jpg)   

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-01-03.jpg)   

    - 可以转化为数字的：int  
    - 其他字符：embstr（对象头和SDS对象连续存储在一起）和raw（两个对象头在内存地址上一般是不连续的），其中44的标准其实就跟完整的 embstr 对象需要的内存大小有关   

##### Hash

- 常用命令: hget,hset,hgetall 等  
- Hash 是一个 string 类型的 field 和 value 的映射表，有点像Map<String,Map<field,value>>，hash 特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象中的某个字段的值   
- 一个hash中最多包含2^32-1键值对  
- redis的key的过期功能只能对键操作，而**Hash结构不能单独对某一个filed设置过期功能**  
- **底层存储结构**：压缩列表（元素对象较少时）或者字典
    - 实现方式是hash表，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用  
    - redis解决hash冲突的方法是链地址法，被分配到同一个索引上的多个键值对会连接成一个单向链表  
    - 扩容  
    当 hash 表中元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是原数组大小的 2 倍，但是如果 Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容 (dict_can_resize)，但是如果 hash 表已经非常满了，元素的个数已经达到了第一维数组长度的 5 倍 (dict_force_resize_ratio)，说明 hash 表已经过于拥挤了，这个时候就会强制扩容  
    - 缩容  
    当 hash 表因为元素的逐渐删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。缩容的条件是元素个数低于数组长度的 10%。缩容不会考虑 Redis 是否正在做 bgsave  
    - 渐进式rehash  
    也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。  


##### List

- 常用命令: lpush,rpush,lpop,rpop,lrange 等  
- list 就是链表，它的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销    
- 可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询  
- 最多包含2^32-1元素  
- **底层存储结构**：早期版本中是压缩列表（ziplist）或者双向链表linkedlist，后来采用**quicklist**代替了ziplist和linkedlist  
    - 是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值，而且可以快速定位元素（有点数组的感觉）  
    - 压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存  
    - quicklist是ziplist和linkedlist的混合体，将linkedlist按段拆分，每一段使用ziplist来紧凑存储，多个ziplist之间使用双向指针串联，单个ziplist长度8k字节，超出这个字节数，新起一个ziplist  
    ![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-01-04.jpg)   

##### Set

- 常用命令: sadd,spop,smembers,sunion 等  
- set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的  
- **底层存储结构**：IntSet数组（元素对象较少时，可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素）或字典  


##### Sorted Set

- 常用命令: zadd,zrange,zrem,zcard 等  
- 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列  
- **底层存储结构**：压缩列表（元素较少的时候）或跳表  
    ![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-01-05.jpg)   
    - 由很多层结构组成，每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的节点  
    - 上一层的元素是当前层的元素的子集  
    - **链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点**  
    - 最底层的链表包含了所有的元素  
    - 元素越多，查找效率越高，空间换时间  

### key过期了怎么办？
这里就涉及到redis的过期策略：定期删除+惰性删除  
##### 定期删除
redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载  
##### 惰性删除
定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。也就是定期删除没有涉及到的key在过期之后，如果再被检索到的话再执行删除  
### 内存淘汰机制
这样一个场景：MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？  
- redis 提供 6种数据淘汰策略  
    - **volatile-lru**：从已设置过期时间的数据集（server.db\[i\].expires）中挑选最近最少使用的数据淘汰  
    - **volatile-ttl**：从已设置过期时间的数据集（server.db\[i\].expires）中挑选将要过期的数据淘汰  
    - **volatile-random**：从已设置过期时间的数据集（server.db\[i\].expires）中任意选择数据淘汰  
    - **allkeys-lru**：**当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）**  
    - **allkeys-random**：从数据集（server.db\[i\].dict）中任意选择数据淘汰  
    - **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错  

### 持久化机制
Redis支持持久化，而且支持两种不同的持久化操作：一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF）  
##### 快照持久化
Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用  
快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：  
```txt
save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```
##### 追加文件持久化
- 开关  
与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过`appendonly yes`参数开启  
- 存储位置  
开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof 
- 三种不同的 AOF 持久化方式  

```txt
appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no      #让操作系统决定何时进行同步
```
#####  Redis 4.0 对于持久化机制的优化
Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。
如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差  


### 其他坑
##### ip绑定问题
- Connection refused: connect  
把Redis的配置文件redis.conf里的 bind localhost（或者bind 127.0.0.1，表明只有该主机才能访问）注释掉，或者修改为：bind ip表明，只能通过ip访问  

    