---
layout:     post
title:      "可不敢吹自己会Redis-02"
subtitle:   "为什么Redis这么快？"
date:       2021-04-03
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-bk.png"
tags:
    - Java
    - Redis

---
> 资料来源于网络上各位前辈（闪客sun）

### 前言
大家都知道Redis即使是单线程也能在高并发的场景下表现不俗，也都知道底层用的是I/O多路复用，但是真正知道什么是I/O多路复用吗？为什么会逐渐发展处这样的技术呢？这些都是需要自己去认真思考的，知其然也要知其所以然。
### 为什么Redis这么快
##### 阻塞IO
最开始的时候，网络I/O采用的是阻塞IO，就像下面的伪代码那样：
```java
listenfd = socket();   // 打开一个网络通信端口
bind(listenfd);        // 绑定
listen(listenfd);      // 监听
while(1) {
  connfd = accept(listenfd);  // 阻塞建立连接
  int n = read(connfd, buf);  // 阻塞读数据
  doSomeThing(buf);  // 利用读到的数据做些什么
  close(connfd);     // 关闭连接，循环等待下一个连接
}
```

动图展现出来就是下面这样：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-02-01.gif)  
<center>阻塞IO示意图</center>  
可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。其中read 函数的底层会阻塞在下面两个阶段：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-02-02.gif)  
<center>read函数实现过程</center>  
总结一下，传统的阻塞IO大致流程如下：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-02-01.jpg)  
<center>传统的阻塞IO过程</center>  
问题的根本在于：  
**<font color=red>如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接</font>**

##### 非阻塞IO
既然问题在于read函数上，那么能不能改造一下呢？换做是我，肯定会想到每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。但是，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的

所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，而是要**恳请操作系统为我们提供一个非阻塞的 read 函数**，这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待

这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务，这种方法结合上层应用的多线程就能比较好的解决传统阻塞IO的问题了（注意是“比较好”，自然问题还是有的），动图表示如下：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-02-03.gif)  
<center>改进之后的read函数</center>  
其中有个细节：  
非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。**当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回**

##### IO多路复用-select
上面的非阻塞IO+多线程虽然解决了新连接不被阻塞的问题，但是带来了新的问题：**为每个客户端创建一个线程，服务器端的线程资源很容易被耗光**  
所以，IO多路复用应运而生，最开始IO多路复用的原理如下：  
可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里，然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法，这样就**成功用一个线程处理了多个客户端连接**  
这个时候就有个疑问了：每次都要去调用read函数，从上面也知道read函数涉及到了用户态和内核态的切换，那岂不是有很多次多于的切换开销呢？有没有办法：系统提供给我们一个有这样效果的函数，**将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题**  
所以，select函数就来了：  
select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-02-04.gif)  
<center>select函数的大致过程</center>  
这里可以看一下select的大致伪代码，通过三个线程来进行无休止的循环来实现：  
```java
//线程1的循环：不断接受客户端连接，并把 socket 文件描述符放到一个 list 里
while(1) {
  connfd = accept(listenfd);
  fcntl(connfd, F_SETFL, O_NONBLOCK);
  fdlist.add(connfd);
}

//线程2的循环：不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历
while(1) {
  // 把一堆文件描述符 list 传给 select 函数
  // 有已就绪的文件描述符就返回，nready 表示有多少个就绪的
  nready = select(list);
  ...
}

//线程3的循环：当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销
while(1) {
  nready = select(list);
  // 用户层依然要遍历，只不过少了很多无效的系统调用
  for(fd <-- fdlist) {
    if(fd != -1) {
      // 只读已就绪的文件描述符
      read(fd, buf);
      // 总共只有 nready 个已就绪描述符，不用过多遍历
      if(--nready == 0) break;
    }
  }
}
```

总结了一下select函数的一些细节：  
- select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）  
- select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）  
- select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。比如加入10000个连接中，真正在发生IO的就一两个，那么剩下的也要被遍历然后调用read函数，这岂不是浪费了？（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）  

##### IO多路复用-poll
**它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制**

##### IO多路复用-epoll
epoll主要就是针对select的三个问题进行了改进：  
- 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可  
- 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒  
- 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合  

核心在于这三个函数：`epoll_create`、`epoll_ctl`（向内核添加、修改或删除要监控的文件描述符）、`epoll_wait`（类似发起了 select() 调用）：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-redis-02-05.gif)  
<center>epoll模型的大致过程</center>  

##### 总结
- 一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，这是传统阻塞IO  
- 为了破这个局，程序员在上层应用通过多线程来防止主线程卡死  
- 后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个while线程内完成多个文件描述符的读取（没有就直接快速返回-1），这就是 非阻塞 IO  
- 但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用，后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 IO 多路复用  
- 多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足

引用闪客sun大佬的一段总结：  
>所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。如果你建立了这样的思维，很容易发现网上的一些错误。比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加一个道理。