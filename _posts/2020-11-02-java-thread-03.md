---
layout:     post
title:      "怎么都在谈高并发-03"
subtitle:   "线程安全级别、synchronized、ReentrantLock、ReentrantReadWriteLock、Condition、CAS、锁"
date:       2020-11-02
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-thread-bg.jpg"
tags:
    - Java
    - 多线程
---
> Java多线程编程核心技术-高宏岩2015版-读书笔记

### 前言
终于到了老生常谈的线程安全，在这之前，那些线程的基础，变量的特性，虚拟机是采用什么策略来保持变量的同步的等等都是很重要的。正式因为有了这些，现在来谈线程安全，才能有更深的理解  
### 多线程会遇到什么问题？
- 线程安全问题  
    - 原子性：可以参考后面原子性的介绍  
    - 可见性：可以参考java的内存模型中的介绍  
- 活跃性问题  
    - 死锁：多个线程因为环形等待锁而永远阻塞  
    - 活锁：当多个线程都在运行并且修改各自的状态，而其他线程都彼此依赖这个状态，导致任何一个线程都无法继续执行，只能重复自身的动作和修改自身的状态  
    - 饥饿：如果一个线程无其他异常却迟迟不能继续运行，比如低优先级别的线程（非酋到极致的线程）  
- 性能问题  
    - 创建线程开销  
    - 线程上下文切换

### 线程安全级别
##### 不可变
顾名思义，随便线程怎么折腾，始终保持“初心不变”的变量，属于不可变级别。比如`final`关键字修饰，这样就不会发生this引用逃逸。这里有两种类型：  
- 被final修饰的基本数据类型：随便折腾  
- 被final修饰的对象：需要保证对象的行为不会对其状态产生影响，比如`java.lang.String`类对象、枚举类。具体怎么保证呢？只要把对象中带有状态的变量都声明为final就可以

##### 绝对线程安全
即使一个类的所有方法都被修饰成同步，也不意味着用它的时候永远不需要同步手段，比如Vector中remove和get容易发生get的元素恰好刚刚被remove掉
##### 相对线程安全
这才是我们通常意义上所讲的“线程安全”，一般是说对一个对象单独的操作是线程安全的，调用的时候不需要做额外的同步处理。但是，如果有一些特殊顺序的连续调用时，就需要调用方用额外的方式来处理同步问题了。比如Vector、HashTable、Collections中的synchronizedCollection()方法包装的集合
##### 线程兼容
这是我们通常意义上所讲的“线程不安全”，如果对象本身并不是线程安全的，但是通过在调用方正确的使用约束来保证对象可以在并发的环境中进行使用，比如ArrayList、HashMap等
##### 线程对立
也就是说，这个级别的线程安全根本就不支持多线程。一旦并发，基本上就是死锁走起，直接GG，最为明显的例子就是thread类的`suspend()`方法和`resume()`方法，二者是对立的，所以目前这两个方法都已经废弃了
### 线程安全的实现方法
##### 互斥同步（阻塞同步）
- **互斥和同步有啥关系**  
1. 同步是指多个线程并发访问共享数据的时候，保证共享数据在同一时刻只被一个线程使用  
2. 互斥是实现同步的一种手段，常见互斥实现方式有临界区、互斥量和信号量  
3. **互斥是操作手段，同步是操作效果；互斥是方法，同步是目的**  
- **互斥同步手段一：synchronized关键字**  
这是**基于原生语法层面的互斥手段**，synchronized关键字在经过编译后，会在同步块的前后生成对应的两个字节码指令（monitorenter和monitorexist），这两个字节码都需要一个reference类型的参数来指定要锁定和解锁的对象。在同步代码块中，这个reference往往指向一个对象。在同步方法中，则需要根据synchronized修饰的是实例方法还是类方法（静态方法）分别指向对应的实例对象或者Class对象  
虚拟机在执行monitorenter指令时，首先要尝试获取reference对应的锁。如果这个对象没被锁定。或者当前线程已经拥有了那个对象的锁，就把锁的计数器加1，等到执行monitorexist指令时会将锁计数器减1，当计数器为0时。锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外个线程释放  
java中的线程是映射到操作系统的原生线程上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这里就需要切换用户线程为核心线程，有可能这一过程消耗较长的时间。为了解决这种问题，自旋锁应运而生  
synchronized关键字可以和`wait()`和`notify()`\/`notifyAll()`方法实现等待/通知模式  
- **互斥同步手段二：ReentrantLock类**  
ReentrantLock是JDK1.5新增的类，实现互斥同步的方式就比synchronized复杂一点点，主要通过这个锁的`luck()`获取锁和`unluck()`释放锁，为了保险起见一般配合`try/finally`方法使用来捕获`InterruptedException`异常，然后在finally中进行锁释放操作  
既然使用要复杂一点点，那功能自然比synchronized就要多一些：  
**功能：**  
1. 等待可中断  
如果持有锁的线程一直不释放，正在等待该锁的线程可以放弃等待，开始做其他事情，具体是通过`lockInterruptibly()`方法来实现中断这个线程，线程被中断后抛出`InterruptedException`异常，其他线程就能正常获取锁了，而且程序主动捕获异常之后也可以进行相应的处理，感觉这个可以用来解决那种死锁  
2. 可实现公平锁  
ReentrantLock默认使用的是非公平锁，可以通过带布尔值的构造函数来使用公平锁。首先，什么是公平锁？和字面意思一样，要求线程按照先来先得（FIFO）的顺序获得锁（这个就适合那种“非酋”的线程，只要肯努力，就能优先执行）与之相对应的是非公平锁，锁一旦释放，任何一个正在等待该锁的线程都有机会获得该锁，比如**synchronized的锁和ReentrantLock的默认锁就是非公平**    
3. 锁可以绑定多个条件  
这里的条件是指J.U.C包（`java.util.current`）里的`Condition`类。在`synchronized`里面，锁对象的`wait()`、`notify()`和`notifyAll()`只可以实现一个隐含的条件。对比之下，ReentrantLock的锁可以实现多个条件，通过把多个Condition对象与锁绑定即可。ReentrantLock类如果要实现等待/通知模式的话，需要和condition类结合，同时该方法可以唤醒指定种类的线程  
**几个方法**：  
1. getHoldCount()：查询当前线程保持此锁定的个数，也即调用lock()方法的次数  
2. getQueueLength()：返回正等待获取此锁定的线程估计数，比如有5个线程，1个线程首先执行await()方法，那么返回值为4，即4个线程在等待lock的释放  
3. getWaitQueueLength()：返回等待与此锁定相关的给定条件Condition的线程估计数比如有5个线程都执行了同一个condition对象的await()方法，则返回无  
4. hasQueuedThread()：查询指定的线程是否正在等待，输入参数thread，返回布尔类型  
5. hasQueuedThreads()：查询是否有线程正在等待获取此锁定  
6. hasWaiters()：查询是否有线程正在等待与此锁定有关的condition条件，输入condition  
7. isFair()：判断是不是公平锁  
8. isHeIdByCurrentThread()：查询当前线程是否保持此锁定  
9. isLocked()：查询此锁定是否由任意线程保持  
10. locklnterruptibly()：如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常  
11. tryLock()：仅在调用时锁定未被另一个线程保持的情况下，才获取该锁  
12. tryLock(long timeout,TimeUnit unit)：如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定  

**AbstractQueuedSynchronizer**
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-thread-03-01.jpg)  
<center>AbstractQueuedSynchronizer的原理</center>  
这就是常说的并发中的AQS，在 ReentrantLock类中通过`abstract static class Sync extends AbstractQueuedSynchronizer`来引入，类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它  
1. **核心在于`volatile int state`（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）**  
2. AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）

**Condition类：**  
既然讲到Condition类，这里就扩展一点。在使用ReentrantLcok类结合condition类的时候，往往离不开condition类的几个方法：  
1. Condition类中的await()==Object类的wait()方法  
2. Condition类中的await(long time, TimeUnit unit)==Object类的wait(long timeout)方法  
3. Condition类中的signal()==Object类的notify()方法  
4. Condition类中的signalAll()==Object类的notifyAll()方法  
5. 和wait()方法一样，如果在使用await()方法时，也需要先获得同步监视器，否则抛出IllegalMonitorStateException  

**ReentrantReadWriteLock类**  
为什么会出现ReentrantReadWriteLock类呢？因为ReentrantLock其实和synchronized关键字一样，一次只能有一个线程访问被锁住的代码，虽然安全，但是效率有点感人。如果一些共享变量，访问的次数远远大于修改的次数，那么是不是可以只让修改的操作互斥呢？所以ReentrantReadWriteLock类就应运而生  
1. 构成  
ReentrantReadWriteLock有两个锁，读锁（`lock.readLock.lock()/lock.readLock.unlock()`）和写锁(`lock.writeLock.lock()/lock.writeLock.unlock()`)  
其中，读锁是共享锁，写锁是排他锁。怎么理解呢？只要此时没有线程Thread进行写入操作，此时进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作  
2. 特征  
`读写`、`写读`、`写写`都是互斥的；`读读`是异步的，非互斥

##### 非阻塞同步
阻塞同步和非阻塞同步主要是根据对同步采用的策略来进行划分的，前者认为一个共享数据如果不进行主动的互斥同步，那么就肯定会有问题。这样的想法给人有一点不相信任何人，带有悲观的感觉（事务中的悲观策略也是异曲同工），这样虽然保证了安全，但是在进行线程暂停、唤起（因为这个需要用户态核心态之间转换，特别耗时）、锁计数器等操作的时候，其实是很消耗时间的（经常说的锁的自旋，其实就是为了解决这个问题）。所以，非阻塞同步就出现了  
- **硬件指令集**  
非阻塞同步基于冲突监测的乐观并发策略，先进行正常操作，如果没有线程来干扰，那就算是执行成功，如果出现了线程争抢数据，再进行补救。当然，这一套乐观操作都要依赖硬件指令集的高速发展，只有这样才能保证操作和冲突检测这两个步骤具有原子性，其中对此有功劳的处理器指令有：  
1. 测试并设置  
2. 获取并增加  
3. 交换（Swap）  
4. **比较并交换（Compare And Swap即CAS）**  
5. 加载链接  
- **CAS操作**  
经常听到的自然就是循环CAS了，这个自带原子性的指令其实完成了三个行动：当且仅当变量符合旧条件下的预期值时，处理器才会用新的预期值替换当前变量值，否则就不会更新。**注意：无论是否更新了变量值，返回的都是原来的对应的地址**，话不多说，直接上代码  
```java
public final int getAndIncrement() {  
    for (;;) {  
        int current = get();  
        int next = current + 1;  
        if (compareAndSet(current, next))  
            return current;  
    }  
}  
```
通过一个无限循环，不断的将一个比自己大1的值赋值给自己，如果失败了则发现最新的值和当前获取到的值不一致了，于是再次循环，直到成功为止。看起来很完美，但是循环CAS也存在问题：  
1. ABA问题  
如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现它的值没有发生变化，但实际上却发生了。解决思路就是使用版本号（带标记的原子引用类`AtomicStampedReference`），在变量前面追加版本号，那么A——B——A 就变成了1A——2B——3A。其实，大部分时候是不需要理会这个ABA问题的，因为如果都到了标记ABA这一步了，还不如使用synchronized  
2. 循环时间长开销大  
3. 只能保证一个共性变量的原子操作，当多个共享变量操作时，循环CAS就无法保证操作的原子性了。但从JDK1.5开始，JDK提供了`AtomicReference类`来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作

#### 无同步方案
**如果代码天生就是线程安全的，就不需要同步方案了**，举例：  
- 可重入代码  
所有的可重入代码都是线程安全的，但并非所有线程安全的代码都是可重入的  
- 线程本地储存  
如果，能够把共享数据的代码放到同一个线程中的话，那就可以采用这种线程本地储存的方式实现无同步方案，**最为经典的就是Web请求，一个请求对应一个服务器线程**。通过ThreadLocal类来实现，每一个Thread对象都包含一个ThreadLocalMap对象。对象中放的内容是一组以ThreadLocal.threadLocalHashCode为键（独一无二的），本地线程变量为值的K-V键值对。使用这个可以在对应线程的ThreadLocalMap中找到对应的本地线程变量

### 锁优化
##### 适应性自旋（Adaptive Spinning）
- 自旋锁  
为什么会出来自旋锁这个东西呢？从前面可以知道，锁的同步过程中，用户状态和内核状态切换非常耗时的。试想一下，如果持锁时间很短，但是频率很高，这是很浪费性能的。所以，前辈们就想出了一个办法，让线程试着自己“旋转”等待一下，说不定在等待的这段时间里面，锁就被其他线程释放了  
JDK1.6开始，自旋锁就默认开启了。万事都不是绝对的，当持锁时间很长的时候，自旋就不是减轻计算机负载反而是加重负载了，所以有了一个自旋时间的设定。超过了自旋时间，还未得到锁的话，就采用传统方式把线程挂载起来了，**自旋次数默认是10次，可通过`-XXPreBlockSpin`来设置**  
- 自适应自旋锁  
**这是JDK1.6中产生的技术**，自适应的地方先进在什么地方呢？不在需要等待固定的自旋时间了，**等待时间根据前一次在同一个锁上的自选时间和锁拥有者的状态来决定**。举个例子：如果在同一个锁对象上，当前等待线程在前不久才刚刚成功获得过锁，并且此时持有锁的线程正在运行，那么在第一次自旋完成后虚拟机就会认为接下来的这次自旋也很有可能再次成功，也就是说会让这次自旋等待更长的时间  

##### 锁消除（Lock Elimination）
代码里面写了同步的要求，真正到了虚拟机即时编译器运行时，如果虚拟机检测到（编译优化技术）这个垃圾代码根本就不可能存在共享数据竞争的锁进行消除（有点像IDEA自动获取到代码的一些低级bug）。这里就有点意思，自己写的代码，为啥会有自己都不知道有没有加入一些没必要的同步措施呢？那是因为有些API的源码里面自带就有同步操作，举个例子：常用的StringBuffer.append()方法就是被synchronized修饰的，但是使用的时候一般的例子中基本上是被锁消除的
##### 锁粗化（Lock Coarsening）
类似于锁消除，都是虚拟机优化的一种方式，当它探测到有一系列零碎加锁操作都是对同一个对象的时候，它会将锁的范围扩大
##### 轻量级锁（Lightweigt Locking）
**这是JDK1.6中产生的技术**，本质是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗  
轻量级锁能够提升程序同步性能主要是因为经验表明，绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争的话，轻量级锁使用CAS操作就避免了使用互斥量的开销。但是，如果存在锁竞争的话，除了互斥量的开销外，还额外发生了CAS操作，所以也要看情况使用轻量级锁  
关于轻量级锁是如何加锁和释放锁的，可以参考这篇[博客]()
##### 偏向锁（Biased Locking）
**这是JDK1.6中产生的技术**，轻量级锁目标在于减少同步使用的互斥量，而偏向锁力求在无竞争的时候，把整个同步都消除掉，连CAS都不会执行。具体实现起来，可以理解为锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设为"01"，也就是偏向模式。同时，使用CAS操作把获取到这个锁的线程ID也记录到对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块的时候，虚拟机都可以不再进行任何同步操作（包括locking、unlocking以及对mark word的update等）。当有另外一个线程尝试获取这个锁的时候，偏向模式就宣告结束了，根据撤销锁后对象的状态可以恢复到未锁定或者轻量级锁定  
**偏向锁可以提高带有同步，但是无竞争的程序性能，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的**可以通过使用`-XX:-UseBiasedLocking`来禁止偏向锁优化，反而可以提升性能  