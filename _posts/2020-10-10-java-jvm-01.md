---
layout:     post
title:      "细嚼慢咽JVM-01"
subtitle:   "运行时数据区域、三种常量池、直接内存、对象"
date:       2020-10-10 23:59:00
author:     "ThreeJin"
header-img: "https://i.loli.net/2020/09/23/cpdwJsZi93e8LNB.png"
tags:
    - Java
---
> 深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)-读书笔记。

### 前言
&emsp;&emsp;两年前，粗略看了一遍《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》这本书，那个时候的主要目的是在于了解JVM的一些基本概念与构成。涉及到书中的一些细节，也没有想过要去深究探讨。同时，对于调优的一些案例也没进行实操。最近在工作中亲身经历了一次OOM的事故的踩坑排坑后，计划开始重拾这本书。整个周期可能比较长，所以我打算一边学习一边整理记录，并结合近一年以来的一些积累不断更新。我深知，整个JVM其实是很庞大的，仅凭这一本书所了解到的内容也只是冰山一角。不求面面俱到，但求精益求精。
### 运行时数据区域
此处应该放上分布图
#### 程序计数器
- 当前线程所执行的字节码行号指示器
- 每个线程都有自己独立的程序计数器，且互不影响
- 如果线程正在执行的是java方法，则程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则程序计数器值为空（undefined）。**程序计数器是Java虚拟机规范中唯一一个没有规定任何OOM情况的区域。**

#### Java虚拟机栈
- 描述的是Java方法执行的内存模型
- 栈帧：局部变量表，操作数栈、动态链接、方法出口等信息

#### 本地方法栈
- 虚拟机使用到的Native方法

#### Java堆/GC堆
- 可以处于物理上不连续的内存空间，只要逻辑上连续即可
- 实现时既可以固定大小，也可以扩展

#### 方法区
- 虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 永久代的概念只存在于HotSpot虚拟机（Java6及以前）上，其他如IBM J9则没有
- 该区域的内存回收目标主要是针对常量池的回收和对类型的卸载
- 运行时常量池：存放编译期生成的各种字面量和符号引用

### 三种常量池
&emsp;&emsp;在这之前，我所理解的常量大体上有类中作为成员变量的常量（一般会被private static final修饰）、方法中作为局部变量的常量（有直接显示定义的也有通过其他方法产生的）。不同的常量最终到了JVM里面会以什么样的形式存在呢？这里需要引入JVM中的三种常量池：**字符串常量池、class常量池以及运行时常量池**
#### 字符串常量池（string pool）
- **是什么**
在HotSpot VM里实现字符串常量池功能的是一个StringTable类，它是一个Hash表；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。
**注**：<font color=red>在JDK6中，StringTable的长度是固定的，长度就是1009，因此如果放入字符串常量池中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；在JDK7及之后，StringTable的长度可以通过参数指定，默认值大小长度是1009</font>  
`-XX:StringTableSize=66666`  
其中：String.intern()方法的作用是如果在字符串常量池存在则返回字符串常量池的字符串引用，如果字符串常量池中不存在，则将字符串放入字符串常量池中，并且返回自身的引用。目的是为了让字符串重用，减少内存使用。
下面可以通过一个例子进行演示说明：
```java
    String s1 = "Hello";
    String s2 = "Hello";
    String s3 = "Hel" + "lo";
    String s4 = "Hel" + new String("lo");
    String s5 = new String("Hello");
    String s6 = s5.intern();
    String s7 = "H";
    String s8 = "ello";
    String s9 = s7 + s8;
    System.out.println(s1 == s2);  // true
    System.out.println(s1 == s3);  // true
    System.out.println(s1 == s4);  // false
    System.out.println(s1 == s9);  // false
    System.out.println(s4 == s5);  // false
    System.out.println(s1 == s6);  // true
```
- **在哪儿**
在JDK6及之前版本，字符串常量池是放在Perm Gen区(也就是方法区中的永久代，在堆外)；**在JDK7版本，字符串常量池被移到了堆中**。至于为什么移到堆内，大概是由于方法区的内存空间太小了
- **里面有些什么**
在JDK6及之前版本中，String Pool里放的都是字符串常量； 在JDK7中，由于String#intern()发生了改变，因此String Pool中也可以存放位于堆内的字符串对象的引用  
**<font color=red> 字符串常量池中的字符串只存在一份！</font>**  
#### class常量池(constant pool table)
- **是什么**
我们写的每一个Java类被编译后，就会形成一份class文件，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池；  
**<font color=red> 每个class文件都有一个class常量池！</font>**  
- **里面有些什么**
class常量池包含编译器生成的各种**字面量(Literal)**和**符号引用(Symbolic References)**。
字面量：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等
符号引用：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符  
`int a=67`  
其中67就是字面量，a可以理解为符号引用（狭义理解）。为什么说这样理解符号引用是狭义的，是因为**符号引用，在类加载层面上讨论比较多，源码级别只是一个形式上的讨论。**可以把符号引用看作一个文件的软链接（类似于Linux），当使用这个软连接的时候，才会真正解析它，展开它找到实际的文件。当一个类被加载时，该类所用到的别的类的符号引用都会保存在常量池，实际代码执行的时候，首次遇到某个别的类时，JVM会对常量池的该类的符号引用展开，转为直接引用，这样下次再遇到同样的类型时，JVM就不再解析，而直接使用这个已经被解析过的直接引用。  
到这里，我发现书上在class常量池这一块讲得也不是很仔细。或者说没有让我有种很清晰的认识，所以去网上找了相关的资料，发现有两篇博客写得很好，：[Class文件中的常量池(上)](https://blog.csdn.net/hxcaifly/article/details/82887552)和[Class文件中的常量池(下)](https://blog.csdn.net/hxcaifly/article/details/82887609)  
#### 运行时常量池
- **是什么**
运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用
- **在哪儿**
**存在于方法区：**JVM在执行某个类的时候，必须经过**加载**、**连接**、**初始化**，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

### 直接内存
- 直接内存的分配不受Java堆大小的限制，受本机内存限制

### 对象
#### 对象创建的时候发生了什么
- 首先常量池中定位并检查这个引用代表的类是否已经被加载、解析初始化，如果没有则先执行相应的类加载过程
- 分配新内存并初始化为零值，分配方法有指针碰撞和空闲列表；
- **指针碰撞**：适用于堆内存完整的情况，已分配的内存和空闲内存分表在不同的一侧，通过一个指针指向分界点，当需要分配内存时，把指针往空闲的一端移动与对象大小相等的距离即可，用于Serial和ParNew等不会产生内存碎片的垃圾收集器
- **空闲列表**：适用于堆内存不完整的情况，已分配的内存和空闲内存相互交错，JVM通过维护一张内存列表记录可用的内存块信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录，最常见的使用此方案的垃圾收集器就是CMS。
- CAS+失败重试保证原子性
- ...待补充

#### 对象的内存布局
##### 对象头
- 对象自身的运行时数据
哈希码(HasInCode),  CC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等
- 类型指针
对象指向它的类元数据的指针，虚拟机也过这个指针来确定对象是哪个类的实例，但并不是所有虚拟机的实现都必须在对象数据上保留类型指针

##### 实例数据
- 无论是从父类继承下米的，还是在子类中定义的
- 相同宽度的字段被分配到一起

##### 对齐填充
- 起着占位符的作用

#### 对象的访问定位
##### 句柄
- Java堆划分出一个句柄池，包含了对象实例数据和类型数据的各自具体地址信息
需要图片说明
- reference中存储的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改

##### 直接指针（更快）
- reference中存储的直接就是对象地址
- 图片说明

### 总结
- 未完。
