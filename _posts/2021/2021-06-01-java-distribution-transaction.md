---
layout:     post
title:      "聊一聊分布式-01"
subtitle:   "分布式事务"
date:  2021-06-01
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/threadpool.jpg"
tags:
    - Java
    - 分布式
    - Transaction
---
> 来源于公众号上的各位大佬文章（三太子敖丙等）总结

### 前言
这篇文章的绝大部分内容都是来自于网络上的各位前辈的资料以及自己的一些感悟。老实说，涉及到分布式事务的东西还真的没有实操过。在目前的工作之中，分布式是有在玩，但是真正涉及到分布式事务的东西却没有怎么用起来。或者说，是我在开发的时候，压根儿就没有想到过还有分布式事务这个东西。说白了，就是并发量不到一定的级别，其实是很难出现分布式事务的问题的。
### 什么是分布式事务？
毋庸置疑，本地的事务一般是交给了数据库来完成，很省事儿，但是一旦整个应用拆分且分布式部署起来后，各自本地的事务就没法再让数据库来保证了。以互联网中的一个电商例子说明：  
一般来说，下单和减库存往往会是在不同的服务之中。如果没有分布式事务的保证，一旦出现问题（网络波动，服务器宕机等）会导致下单了但是没减库存或者减库存了但下单失败  

**这个时候，需要在设计和开发的时候保证，下单与减库存的操作要是原子的操作，也就是这两个服务的这两个操作要在同一个事务之中，要么都成功，要么都失败**

**所以，分布式事务是指是指事务的发起者、参与者、数据资源服务器以及事务管理器分别位于分布式系统的不同节点之上。目的是为了解决微服务架构（形式都是分布式系统）中不同节点之间的数据一致性问题**

一般来说，分布式事务的场景有如下三种类别：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-distribution-transaction-04.jpg)  
<center>分布式事务的场景</center>  

分布式事务的实现方式有很多种，比如`XA协议`或者`TCC协议`。其中最具有代表性的是由`Oracle Tuxedo`系统提出的**XA分布式事务协议**，XA对应的实现方案有两阶段提交（2PC）和三阶段提交（3PC）。

### XA协议之2PC
##### 是什么？
2PC（`Two-phase commit protocol`），中文叫二阶段提交  
**二阶段提交是一种强一致性设计**，2PC 引入一个`事务协调者`的角色来协调管理各`参与者`（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段

- **准备阶段**  
    - 协调者会给各参与者发送准备命令，告诉这些参与者快赶紧除了提交事务之外啥事都做完并及时反馈  
    - **协调者会同步等待所有资源的响应**，收到响应后才能进入第二阶段  
    - 此阶段的协调者**有超时机制**：假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令  
- **提交阶段**  
    - 如果准备阶段中所有参与者都返回了成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功  
    - 如果准备阶段中有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败
    
##### 提交阶段失败了怎么办？

- **第二阶段执行的是回滚事务操作**  
不断重试，直到所有参与者都回滚了，不然那些在第一阶段准备成功的参与者会因为在等待协调者的提交命令而一直阻塞着  
- **第二阶段执行的是提交事务操作**  
不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理

##### 协调者故障了怎么办？

- **发送准备命令之前**挂了，还行等于事务还没开始，问题不大  
- **发送准备命令之后**挂了，这就不太行了，因为可能有些参与者都已经准备好且处于事务资源锁定的状态了。此时不仅事务执行不下去，还会因为锁定了一些公共资源而阻塞系统其它操作  
- **发送回滚事务命令之前**挂了，那么事务也是执行不下去，且在第一阶段那些准备成功参与者都阻塞着  
- **发送回滚事务命令之后**挂了，这个还行，至少命令发出去了，很大的概率都会回滚成功，资源都会释放。但是如果出现网络分区问题，某些参与者将因为收不到命令而阻塞着  
- **发送提交事务命令之前**挂了，这是最惨的，此时所有资源都阻塞着  
- **发送提交事务命令之后**挂了，这个还行，也是至少命令发出去了，很大概率都会提交成功，然后释放资源，但是如果出现网络分区问题某些参与者将因为收不到命令而阻塞着  

所以，有必要保证协调者的高可用，这里可以采用**集群+故障选举**的方式保证。但是，因为参与者的状态其实都是维护在协调者这边的，所以即使有选举，但是选举出来的新协调者，未必就知道在此之前所有参与者的全部状态信息

**2PC 是一种尽量保证强一致性的分布式事务，因此它是同步阻塞的，而同步阻塞就导致长久的资源锁定问题，总体而言效率低，并且存在单点故障问题，在极端条件下存在数据不一致的风险**
### XA协议之3PC
##### 是什么？
3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在参与者中也引入了**超时机制**，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-distribution-transaction-02.jpg)  
<center>三阶段提交的流程示意</center>  

- **准备阶段**:CanCommit  
    - 此阶段，协调者只是询问参与者的自身状况，比如到底挂没挂？负载重不重？等等  
    - 好处是，不会一来就干活直接锁资源，使得在某些资源不可用的情况下所有参与者都阻塞着  
- **预提交阶段**:PreCommit  
此阶段和 2PC 的准备阶段一样  
- **提交阶段**:DoCommit  
此阶段和 2PC 一样

##### 有什么改进？
- **3PC对于协调者和参与者都设置了超时时间，而2PC只有协调者才拥有超时机制**  
这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地`commit`从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。
- 通过三个阶段的设计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的

##### 有什么问题？
比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是有可能执行的是回滚操作，这样一来数据就不一致了
### TCC协议
##### 是什么？
`TCC`是一种补偿型事务，该模型要求应用的每个服务提供`try、confirm、cancel`三个接口，它的核心思想是通过对资源的预留（提供中间态），尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留的资源

`2PC` 和 `3PC` 都是数据库层面的，而 `TCC` 是业务层面的分布式事务

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-distribution-transaction-05.jpg)  
<center>TCC的流程示意</center>  

- **Try**  
完成所有业务检查，预留和锁定必须的业务资源  
- **Confirm**  
真正执行的业务逻辑，不作任何业务检查，只使用 `Try` 阶段预留的业务资源，如果失败会一直重试。因此，**只要 `Try` 操作成功，`Confirm` 必须能成功**。另外，`Confirm` 操作需满足幂等性，保证一个分布式事务有且只能成功一次  
- **Cancel**  
释放 `Try` 阶段预留的业务资源。同样的，`Cancel` 操作也需要满足幂等性

##### 角色与特性
- **主业务服务**  
主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动  
- **从业务服务**  
从业务服务是整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作(`Try`)、确认操作(`Confirm`)、取消操作(`Cancel`)三个接口，供主业务服务调用  
- **业务活动管理器**  
业务活动管理器管理控制整个业务活动，包括记录维护 `TCC` 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 `Cancel` 操作

既然是分布式事务，自然TCC也保证了事务的四个特性：  
- 原子性：事务发起方协调各个分支事务全部提交或者全部回滚  
- 一致性：TCC 事务提供最终一致性  
- 隔离型：通过 try 预分配资源的方式来实现数据的隔离  
- 持久性：交由各个分支事务来实现

##### 工作流程
- 主业务服务首先开启本地事务  
- 主业务服务向业务活动管理器申请启动分布式事务主业务活动  
- 然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册从业务活动，然后调用从业务服务的 `Try` 接口  
- 当所有从业务服务的 `Try` 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务  
- 若主业务服务提交本地事务，则 `TCC` 模型分别调用所有从业务服务的 `Confirm` 接口；若主业务服务回滚本地事务，则分别调用 `Cancel` 接口  
- 所有从业务服务的 `Confirm` 或 `Cancel` 操作完成后，全局事务结束

##### 核心要求
- **允许空回滚**  
比如，在`try`阶段中部分参与者没有收到 `try` 请求从而触发整个事务`cancel`操作时，此时`try` 失败或者没有执行 `try` 操作的参与方在收到主业务发起的 `cancel` 请求时，要能够进行空回滚操作  
- **保持幂等性**  
原因是异常发生在`confirm/cancel`阶段时，比如网络超时，则会重复调用参与方的`confirm/cancel`方法，因此需要这两个方法实现上保证幂等性  
- **防止资源悬挂**  
原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方收到的`try`请求比`cancel`请求更晚到达的情况，`cancel`执行空回滚后需要保证后来的`try`方法不可以再被执行

### 基于消息的分布式事务
##### 事务消息
这里有必要说一个东西：  
一般说基于消息的分布式事务，其实大体上分为两种：**基于事务消息的方案**和**基于本地消息的方案**

有什么区别呢？  
普通消息是无法解决本地事务执行和消息发送的一致性问题的。因为消息发送是一个网络通信的过程，发送消息的过程就有可能出现发送失败、或者超时的情况。超时有可能发送成功了，有可能发送失败了，消息的发送方是无法确定的，所以此时消息发送方无论是提交事务还是回滚事务，都有可能不一致性出现

解决这个问题，需要引入事务消息，事务消息和普通消息的区别在于事务消息发送成功后，处于`prepared`状态(比如RocketMQ中的半消息)，不能被订阅者消费，等到事务消息的状态更改为可消费状态后，下游订阅者才可以监听到次消息

可以参考RocketMQ的的消息事务机制  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-distribution-transaction-01.jpg)  
<center>rocketMQ的消息事务图</center>  
核心关注点：**半消息**、**反查事务状态接口（由生产者提供的）**

具体的流程可以梳理成如下：

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-distribution-transaction-06.jpg)  
<center>事务消息的流程图</center>  

- 事务发起者预先发送一个事务消息  
- MQ 系统收到事务消息后，将消息持久化，消息的状态是“待发送”，并给发送者一个 ACK 消息  
- 事务发起者如果没有收到 ACK 消息，则取消本地事务的执行；如果收到了 ACK 消息，则执行本地事务，并给 MQ 系统再发送一个消息，通知本地事务的执行情况  
- MQ 系统收到消息通知后，根据本地事务的执行情况更改事务消息的状态，如果成功执行，则将消息更改为“可消费”并择机下发给订阅者；如果事务执行失败，则删除该事务消息  
- 本地事务执行完毕后，发给 MQ 的通知消息有可能丢失了。所以支持事务消息的 MQ 系统有一个定时扫描逻辑，扫描出状态仍然是“待发送”状态的消息，并向消息的发送方发起询问，询问这条事务消息的最终状态如何并根据结果更新事务消息的状态。因此事务的发起方需要给 MQ 系统提供一个事务消息状态查询接口  
- 如果事务消息的状态是“可发送”，则 MQ 系统向下游参与者推送消息，推送失败会不停重试  
- 下游参与者收到消息后，执行本地事务，本地事务如果执行成功，则给 MQ 系统发送 ACK 消息；如果执行失败，则不发送 ACK 消息，MQ 系统会持续推送给消息

##### 本地消息
该种模式的核心思想是事务的发起方维护一个本地消息表，业务执行和本地消息表的执行处在同一个本地事务中。业务执行成功，则同时记录一条“待发送”状态的消息到本地消息表中。系统中启动一个定时任务定时扫描本地消息表中状态为“待发送”的记录，并将其发送到 MQ 系统中，如果发送失败或者超时，则一直发送，知道发送成功后，从本地消息表中删除该记录  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-distribution-transaction-07.jpg)  
<center>本地消息的流程图</center>  

### 最大努力通知型分布式事务
最大努力通知型方案本质是通过引入定期校验机制来对最终一致性做兜底，对业务侵入性较低、对 MQ 系统要求较低，实现比较简单，适合于对最终一致性敏感度比较低、业务链路较短的场景，比如跨平台、跨企业的系统间的业务交互
### 总结
单体数据库事务很容易满足事务的 ACID 四个特性，提供强一致性保证，但是分布式事务要完全遵循 ACID 特性会比较困难。为了追求分布式系统的高可用和高吞吐，**分布式事务的解决方案一般提供的是最终一致性**

通常把提供强一致性的事务称之为**刚性事务**，把提供最终一致性的事务称之为**柔性事务**。刚性事务可以完全满足 ACID 四个特性，柔性事务对事务的 ACID 特性的支持情况如下：  
- 原子性：完全支持  
- 一致性：**只提供最终一致性支持**  
- 隔离性：**不完全保证**，通常为了系统的吞吐和性能，会一定程度上放弃对隔离性的要求  
- 持久性：完全支持

柔性事务一般遵循的是分布式领域中的 `BASE` 理论：

- BA：Basic Availability，基本业务可用性  
- S：Soft state，柔性状态  
- E：Eventual consistency，最终一致性

BASE 理论，是对 CAP 理论的延伸，是对 CAP 中的一致性和可用性进行一个权衡的结果。虽然无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性

CAP 理论告诉我们一个分布式系统无法同时满足一致性, 可用性, 分区容错性，所以在设计上对这三点做取舍。刚性事务追求强一致性，所以牺牲了高可用性；柔性事务通过牺牲一致性换来了系统的高可用性

在系统选择分布式方案时，可以根据对一致性的要求进行选择，业务上有强一致性要求的场景时，优先考虑 XA 规范的两阶段提交；业务上只需要最终一致性的场景时，可以在根据具体场景在柔性事务方案中进行选择