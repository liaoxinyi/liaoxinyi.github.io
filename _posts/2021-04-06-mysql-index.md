---
layout:     post
title:      "又见MySQL-02"
subtitle:   "引擎、索引、执行计划、SQ优化、索引失效"
date:       2021-04-06
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-bk-02.jpg"
tags:
    - MySQL

---
> 资料来源于网络上各位前辈（Hollis等）

### 前言
大家都在说SQL的优化，都在说不要`select *`，都在说要建立索引，那是为什么呢？前年刚刚工作的时候，也是稀里糊涂的，只知道个大概，但是细节一些的东西真的没有好好沉淀一下。
### 引擎  
##### 介绍
- 在MySQL中创建表时可以选择存储引擎。有几种不同的存储引擎，但最常用的是MyISAM和InnoDB，它们都是不同MySQL版本的默认存储引擎  
- 如果在创建表时没有指定存储引擎，那么将使用MySQL版本的默认引擎  
- 在5.5.5之前的MySQL版本中，MyISAM是默认值，但是在5.5.5之后的版本中，InnoDB是默认值

##### 主要区别
- InnoDB较新，MyISAM较老  
- InnoDB更复杂，而MyISAM更简单  
- InnoDB在数据完整性方面更加严格，而MyISAM比较松散  
- InnoDB为插入和更新实现了行级锁，而MyISAM实现了表级锁  
- InnoDB有事务，而MyISAM没有  
- InnoDB有外键和关系限制，而MyISAM没有  
- InnoDB有更好的崩溃恢复，而MyISAM在系统崩溃时无法恢复数据完整性  
- MyISAM有全文搜索索引，而InnoDB没有  
- InnoDB采用聚簇索引，MyISAM采用非聚簇索引

这里有一个总结表：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-10.jpg)  
<center>InnoDB和MyISAM对比</center>  

##### InnoDB
- InoDB的优点  
    - InnoDB应该优先考虑数据完整性，因为它通过关系约束和事务来处理数据完整性  
    - 在写密集型(插入、更新)表中更快，因为它利用行级锁，并且只保留对正在插入或更新的同一行的更改  
- InnoDB的缺点  
    - 由于InnoDB必须处理表之间的不同关系，因此数据库管理员和方案创建者在设计比MyISAM更复杂的数据模型时需要花费更多的时间  
    - 消耗更多的系统资源，如RAM。事实上，很多人都建议在安装MySQL之后，如果不需要InnoDB引擎，就关闭它  
    - 没有全文索引

##### MyISAM
- MyISAM的优点  
    - 设计和创建更简单，因此更适合初学者。不必担心表之间的外部关系  
    - 由于结构更简单，服务器资源的成本更低，因此总体上比InnoDB更快  
    - 全文索引  
    - 特别适合读密集型(select)表  
- MyISAM的缺点  
    - 没有数据完整性(例如，关系约束)检查，这会增加数据库管理员和应用程序开发人员的责任和开销  
    - 不支持在银行等关键数据应用程序中必不可少的事务  
    - 对于频繁插入或更新的表，其速度比InnoDB慢，因为对于任何插入或更新，整个表都是锁定的  

##### 总结
- InnoDB更适合需要频繁插入和更新的数据危急情况  
- MyISAM在不太依赖于数据完整性的应用程序中执行得更好，这些应用程序通常只选择和显示数据

### 索引  
##### 作用  
索引的作用和效果这里就不再赘述了，类似于字典目录的检索一样，提高数据检索的效率。  
##### 分类
不要再一来就是什么B+，B树了，在数据库中，索引是分很多种类的，具体应该针对不同的数据库类型来进行说明  
- Hash 索引  
Hash 索引是比较常见的一种索引，单条记录查询的效率很高，时间复杂度为1。但Hash索引并不是最常用的数据库索引类型，比如**Mysql的Innodb引擎就不支持hash索引**  
    - Hash索引适合精确查找，但是范围查找不适合  
    - 存储引擎都会为每一行计算一个hash码，hash码都是比较小的，并且不同键值行的hash码通常是不一样的，hash索引中存储的就是Hash码，hash 码彼此之间是没有规律的，且 Hash 操作并不能保证顺序性，所以值相近的两个数据，Hash值相差很远，被分到不同的桶中  

- 二叉树索引  
- B数索引  
这两种索引都可以直接参考以前在总结数据结构的时候的内容，[东拉西扯数据结构-02](https://www.threejinqiqi.fun/2020/11/17/java-datastructure-02/)  

- B+树  
    - 在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度  
    - 叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针  
    - 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快  
    - 查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定  
    - 天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高  
    - 全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描  

##### 磁盘存储结构
- 扇区：磁盘的最小存储单位  
- 磁盘块（block）  
文件系统读写数据的最小单位，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么   
- 数据区  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-05.jpg)  

在MySQL的设定中，同一个表空间内的一组连续的数据页为一个extent（区），默认区的大小为1MB，页的大小为16KB。16\*64=1024，也就是说一个区里面会有64个连续的数据页。连续的256个数据区为一组数据区  

##### InnoDB-主键索引结构
**注意：聚簇索引是 MySQL 基于主键索引结构创建的，聚簇索引中数据页记录的是一条记录的完整的记录**

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-01.jpg)  

从上面可以看出，MySQL的innoDB引擎中的B+树索引结构，包含有**数据页和索引页**   

- **索引页**  
    - 记录的是每页数据页的页号和该数据页中最小的主键的记录，**一张不够存就分裂到下一张，索引页太多会往上一层扩散**  
    - 索引页中的记录是通过**单向链表**连接的
    - 可以理解为，索引页其实维护了数据页，那么同时也有用于维护索引页的数据结构：**其实也还叫索引页**，只不过在不同的层级  
    - 也就是说维护索引页的索引页是在真正存储记录和数据页的索引页的上一层

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-02.jpg)  
- **数据页**  
    ![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-06.jpg)  
    <center>数据页的构成</center>  
    - **数据页是其磁盘管理的最小单位**  
    - 数据在数据页中的存储是连续的，数据页中的数据是按照主键排序的（如果没有主键, 则会Unique key做主键，如果没有unique则由 MySQL自己维护的 `ROW_ID` 来排序的）   
    - **数据页和数据页之间是通过双向链表来关联的，数据与数据之间是通过单向链表来关联的**  
    - 随着数据写入，就导致后一个数据页中的所有行并不一定比前一个数据页中的行的id大，此时触发页分裂的逻辑。页分裂的目的就是保证：后一个数据页中的所有行主键值比前一个数据页中主键值大。所以，一般不用UUID作为主键id，因为不是自增的，容易触发页分裂    
    - InnoDB存储引擎中默认每个页的大小为16KB，可通过参数`innodb_page_size`将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：  
    
    ```sql
    mysql> show variables like 'innodb_page_size';
    ```

系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。**InnoDB在把磁盘数据读入到内存时会以页为基本单位**，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率，而B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块  

**举个例子来证明B+Tree的优势**：
InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作

数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据
##### InnoDB-非主键索引
实际上非主键索引其原理是一样的，MySQL 都是去维护一颗 B+ 树。这意味着我建立多少个索引，MySQL 就会维护多少的B+树。所以，这也是为啥索引不让建立很多个，因为索引也会占用空间

举个例子：现在对`name+age` 建立索引，此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过这个时候的数据就要根据引擎来区分了，innoDB是储存的主键值+key字段，myisam储存的依旧是对应的数据（肯定包含主键值）

在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序

此时每个数据页中的记录存放的实际是索引字段和主键字段，而其他字段是不存的，至于查找，原理和过程跟聚簇索引一样，假设现在执行这样的SQL：`SELECT name FROM student WHERE name='wx'`那么此时的查询是完美的，使用到了索引且不需要回表  
##### 聚簇索引和非聚簇索引
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-03.jpg)  
聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引（理由：数据一旦存储，顺序只能有一种）

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针

**聚簇索引的主键值，应尽量是连续增长的值，而不是要是随机值，不要用随机字符串或UUID，否则会造成大量的页分裂与页移动**

聚簇索引劣势: 如果碰到不规则数据插入时,造成频繁的页分裂，比如下面这种：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-04.jpg)  

##### 回表
假如，现在索引只有name，age，id，而查询的 SQL 是这样子的：  
`SELECT * FROM student WHERE name='wx'`  
那这下子就完蛋了，因为你现在虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？这种情况下，MySQL 就需要进行回表查询了。  
此时 MySQL 就会根据定位到的某条记录中的 id 再次进行聚簇索引查找，也就是说会根据 id 去维护 id 的那个 B+ 树中查找。因为聚簇索引中数据页记录的是一条记录的完整的记录，这个过程就叫回表  
回表的含义：**根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找得到记录的过程叫回表**  

**非主键索引一定会查询多次吗？**  
覆盖索引也可以只查询一次，覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率  
比如，表`covering_index_sample`中有一个普通索引 `idx_key1_key2(key1,key2)`。当通过SQL语句：`select key2 from covering_index_sample where key1 = ‘keytest’`;的时候，就可以通过覆盖索引查询，无需回表

##### 非主键索引的维护过程
对于非主键索引（一般都是联合索引），在维护 B+ 树的时候，会根据联合索引的字段依次去判断，假设联合索引为：`name + address + age`，那么 MySQL 在维护该索引的 B+ 树的时候，首先会根据 name 进行排序，name 相同的话会根据第二个 address 排序，如果 address 也一样，那么就会根据 age 去排序，如果 age 也一样，那么就会根据主键字段值去排序  
同时，对于非主键索引，MySQL 在维护 B+ 树的时候，仅仅是维护索引字段和主键字段，具体的值还是在聚簇索引之中  
##### 索引下推(Index Condition Pushdown)
MySQL 5.6引入了索引下推优化，默认开启，使用`SET optimizer_switch = ‘index_condition_pushdown=off’`;可以将其关闭。  
官方文档中给的例子和解释如下： people表中（zipcode，lastname，firstname）构成一个索引，然后此时有一个条件查询是这样的：  
`WHERE zipcode=‘95054’ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;`    
如果没有使用索引下推技术，则MySQL会通过`zipcode='95054’`从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于`lastname LIKE '%etrunia%'`和`address LIKE '%Main Street%'`来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合`zipcode='95054’`的索引，然后根据`lastname LIKE '%etrunia%'`筛选出符合条件的索引后再返回到MySQL服务端  
最后MySQL服务端基于`address LIKE '%Main Street%'`来判断数据是否符合条件。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数
### 执行计划
一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划  
优化过程大致如下：
- 根据搜索条件，找出所有可能使用的索引  
- 计算全表扫描的代价  
- 计算使用不同索引执行查询的代价  
- 对比各种执行方案的代价，找出成本最低的那一个

### 索引失效
既然索引可以提高查询的效率，那是不是我随随便便搞个索引，然后查询的时候带上这个条件，就能发挥作用了呢？其实不然，这里存在一个现象叫**索引失效**。在讲索引失效前，先复习一个命令：`explain`  
##### explain  
通过explain可以显示出mysql执行的字段内容：  
`explain select * from...`  
- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符  
- select_type: SELECT 查询的类型  
- table: 查询的是哪个表  
- partitions: 匹配的分区  
- type: join 类型  
- **possible_keys**: 此次查询中可能选用的索引  
- **key**: 此次查询中确切使用到的索引  
- ref: 哪个字段或常数与 key 一起被使用  
- rows: 显示此查询一共扫描了多少行. 这个是一个估计值  
- filtered: 表示此查询条件所过滤的数据的百分比  
- extra: 额外的信息

总结起来，导致索引失效的大体上有这些原因：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-07.jpg)  
<center>索引失效总结</center>  
下面以(name,age,pos,phone)索引为例：  

```sql
Create Table: CREATE TABLE `user` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  `age` int(10) DEFAULT '0',
  `pos` varchar(30) DEFAULT NULL,
  `phone` varchar(11) DEFAULT NULL,
  `created_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name_age_pos_phone` (`name`,`age`,`pos`,`phone`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

##### 索引失效1：违反最左前缀法则
如果索引有多列，要遵守最左前缀法则：  
**即查询从索引的最左前列开始并且不跳过索引中的列**  
什么意思呢？意思就是：组合索引，不是使用第一列索引时或者使用第一列索引但是调列了，索引失效  
`explain select * from user where age = 20 and phone = '18730658760' and pos = 'cxy';`  
##### 索引失效2：在索引列上做任何操作
对索引字段进行如计算、函数、（自动or手动）类型转换等操作，会导致索引失效从而全表扫描：  
`explain select * from user where left(name,5) = 'zhangsan' and age = 20 and phone = '18730658760'; `  
##### 索引失效3：索引列上使用not，<>，!=
**不等于操作符是永远不会用到索引的**，因此对它的处理只会产生全表扫描  
优化方法：`key<>0` 改为 `key>0 or key<0`
##### 索引失效4：全表扫描>索引
当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效  
##### 索引失效5：like以通配符开头（'%abc'）
like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效  
##### 索引失效6：数据类型出现隐式转化
如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描
##### 索引失效7：范围查询的右边索引会失效  
`select * from testTable where a>1 and b=2`  
- 首先a字段在B+树上是有序的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引  
- b有序的前提是a是确定的值，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a  
- 大于1的a那部分的B+树里，b字段是无序的，所以b不能在无序的B+树里用二分查找来查询，b用不到索引

##### 索引失效的本质
- 单值索引 
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-08.jpg)  
<center>单值索引B+树示意</center>  
单值索引在B+树的结构里，一个节点只存一个键值对  
- 联合索引 
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-09.jpg)  
<center>联合索引B+树示意</center>  
从本质上来说，联合索引也是一个B+树，和单值索引不同的是，联合索引的键值对不是1，而是大于1个。这里就涉及到B+树的一个排序方式了：  
**先按照第一个字段排序，如果第一个字段出现相等的情况，就用第二个字段排序。字符串的排序方式：先按照第一个字母排序，如果第一个字母相同，就按照第二个字母排序，以此类推**

**所以，如果查询的时候索引没有符合最左前缀法则，或者有跳列，又或者范围查询右边有索引的时候，那么引擎按照已有的索引排序方式是无法定位数据的（第一个索引字段都没找到自然找不到后续字段）**