---
layout:     post
title:      "又见MySQL-02"
subtitle:   "索引、执行计划、SQ优化"
date:       2021-04-06
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-bk-02.jpg"
tags:
    - MySQL

---
> 资料来源于网络上各位前辈（Hollis等）

### 前言
大家都在说SQL的优化，都在说不要`select *`，都在说要建立索引，那是为什么呢？前年刚刚工作的时候，也是稀里糊涂的，只知道个大概，但是细节一些的东西真的没有好好沉淀一下。
### 索引
##### 作用
索引的作用和效果这里就不再赘述了，类似于字典目录的检索一样，提高数据检索的效率。  
##### 分类
不要再一来就是什么B+，B树了，在数据库中，索引是分很多种类的，具体应该针对不同的数据库类型来进行说明  
- Hash 索引  
Hash 索引是比较常见的一种索引，单条记录查询的效率很高，时间复杂度为1。但Hash索引并不是最常用的数据库索引类型，比如**Mysql的Innodb引擎就不支持hash索引**  
    - Hash索引适合精确查找，但是范围查找不适合  
    - 存储引擎都会为每一行计算一个hash码，hash码都是比较小的，并且不同键值行的hash码通常是不一样的，hash索引中存储的就是Hash码，hash 码彼此之间是没有规律的，且 Hash 操作并不能保证顺序性，所以值相近的两个数据，Hash值相差很远，被分到不同的桶中  

- 二叉树索引  
- B数索引  
这两种索引都可以直接参考以前在总结数据结构的时候的内容，[东拉西扯数据结构-02](https://www.threejinqiqi.fun/2020/11/17/java-datastructure-02/)  

- B+树  
    - 在 B+ 树中，所有数据记录节点都是按照键值的大小存放在同一层的叶子节点上，而非叶子结点只存储key的信息，这样可以大大减少每个节点的存储的key的数量，降低B+ 树的高度  
    - 叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针  
    - 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快  
    - 查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定  
    - 天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高  
    - 全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描  

##### 磁盘存储结构
- 扇区：磁盘的最小存储单位  
- 磁盘块（block）  
文件系统读写数据的最小单位，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么   
- 数据区  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-05.jpg)  

在MySQL的设定中，同一个表空间内的一组连续的数据页为一个extent（区），默认区的大小为1MB，页的大小为16KB。16\*64=1024，也就是说一个区里面会有64个连续的数据页。连续的256个数据区为一组数据区  

##### InnoDB-主键索引结构
**注意：聚簇索引是 MySQL 基于主键索引结构创建的，聚簇索引中数据页记录的是一条记录的完整的记录**

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-01.jpg)  

从上面可以看出，MySQL的innoDB引擎中的B+树索引结构，包含有**数据页和索引页**   

- **索引页**  
    - 记录的是每页数据页的页号和该数据页中最小的主键的记录，**一张不够存就分裂到下一张，索引页太多会往上一层扩散**  
    - 索引页中的记录是通过**单向链表**连接的
    - 可以理解为，索引页其实维护了数据页，那么同时也有用于维护索引页的数据结构：**其实也还叫索引页**，只不过在不同的层级  
    - 也就是说维护索引页的索引页是在真正存储记录和数据页的索引页的上一层

![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-02.jpg)  
- **数据页**  
    ![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-06.jpg)  
    <center>数据页的构成</center>  
    - **数据页是其磁盘管理的最小单位**  
    - 数据在数据页中的存储是连续的，数据页中的数据是按照主键排序的（如果没有主键, 则会Unique key做主键，如果没有unique则由 MySQL自己维护的 `ROW_ID` 来排序的）   
    - **数据页和数据页之间是通过双向链表来关联的，数据与数据之间是通过单向链表来关联的**  
    - 随着数据写入，就导致后一个数据页中的所有行并不一定比前一个数据页中的行的id大，此时触发页分裂的逻辑。页分裂的目的就是保证：后一个数据页中的所有行主键值比前一个数据页中主键值大。所以，一般不用UUID作为主键id，因为不是自增的，容易触发页分裂    
    - InnoDB存储引擎中默认每个页的大小为16KB，可通过参数`innodb_page_size`将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：  
    
    ```sql
    mysql> show variables like 'innodb_page_size';
    ```

系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。**InnoDB在把磁盘数据读入到内存时会以页为基本单位**，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率，而B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块  

**举个例子来证明B+Tree的优势**：
InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作

数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据
##### InnoDB-非主键索引
实际上非主键索引其原理是一样的，MySQL 都是去维护一颗 B+ 树。这意味着我建立多少个索引，MySQL 就会维护多少的B+树。所以，这也是为啥索引不让建立很多个，因为索引也会占用空间

举个例子：现在对`name+age` 建立索引，此时 MySQL 根据会 name+age 维护一个单独的 B+ 树结构，数据依旧是存放在数据页中的，只不过这个时候的数据就要根据引擎来区分了，innoDB是储存的主键值+key字段，myisam储存的依旧是对应的数据（肯定包含主键值）

在插入数据的时候，MySQL 首先会根据 name 进行排序，如果 name 一样，就根据联合索引中的 age 去排序，如果还一样，那么就会根据 主键 字段去排序

此时每个数据页中的记录存放的实际是索引字段和主键字段，而其他字段是不存的，至于查找，原理和过程跟聚簇索引一样，假设现在执行这样的SQL：`SELECT name FROM student WHERE name='wx'`那么此时的查询是完美的，使用到了索引且不需要回表  
##### 聚簇索引和非聚簇索引
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-03.jpg)  
聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引（理由：数据一旦存储，顺序只能有一种）

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针

**聚簇索引的主键值，应尽量是连续增长的值，而不是要是随机值，不要用随机字符串或UUID，否则会造成大量的页分裂与页移动**

聚簇索引劣势: 如果碰到不规则数据插入时,造成频繁的页分裂，比如下面这种：  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/java-mysql-02-04.jpg)  

##### 回表
假如，现在索引只有name，age，id，而查询的 SQL 是这样子的：  
`SELECT * FROM student WHERE name='wx'`  
那这下子就完蛋了，因为你现在虽然根据 name 很快的定位到了该条记录，但是因为 name+age 不是聚簇索引，此时的 B+ 树的数据页中存放的仅仅是自己关联的索引和主键索引字段，并不会存其他的字段，所以这个时候其他的属性值是获取不到的，这时候该怎么办？这种情况下，MySQL 就需要进行回表查询了。  
此时 MySQL 就会根据定位到的某条记录中的 id 再次进行聚簇索引查找，也就是说会根据 id 去维护 id 的那个 B+ 树中查找。因为聚簇索引中数据页记录的是一条记录的完整的记录，这个过程就叫回表  
回表的含义：**根据非主键索引查询到的结果并没有查找的字段值，此时就需要再次根据主键从聚簇索引的根节点开始查找，这样再次查找得到记录的过程叫回表**  

**非主键索引一定会查询多次吗？**  
覆盖索引也可以只查询一次，覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率  
比如，表`covering_index_sample`中有一个普通索引 `idx_key1_key2(key1,key2)`。当通过SQL语句：`select key2 from covering_index_sample where key1 = ‘keytest’`;的时候，就可以通过覆盖索引查询，无需回表

##### 非主键索引的维护过程
对于非主键索引（一般都是联合索引），在维护 B+ 树的时候，会根据联合索引的字段依次去判断，假设联合索引为：`name + address + age`，那么 MySQL 在维护该索引的 B+ 树的时候，首先会根据 name 进行排序，name 相同的话会根据第二个 address 排序，如果 address 也一样，那么就会根据 age 去排序，如果 age 也一样，那么就会根据主键字段值去排序  
同时，对于非主键索引，MySQL 在维护 B+ 树的时候，仅仅是维护索引字段和主键字段，具体的值还是在聚簇索引之中  
##### 索引下推(Index Condition Pushdown)
MySQL 5.6引入了索引下推优化，默认开启，使用`SET optimizer_switch = ‘index_condition_pushdown=off’`;可以将其关闭。  
官方文档中给的例子和解释如下： people表中（zipcode，lastname，firstname）构成一个索引，然后此时有一个条件查询是这样的：  
`WHERE zipcode=‘95054’ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;`    
如果没有使用索引下推技术，则MySQL会通过`zipcode='95054’`从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于`lastname LIKE '%etrunia%'`和`address LIKE '%Main Street%'`来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合`zipcode='95054’`的索引，然后根据`lastname LIKE '%etrunia%'`筛选出符合条件的索引后再返回到MySQL服务端  
最后MySQL服务端基于`address LIKE '%Main Street%'`来判断数据是否符合条件。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数
### 执行计划
一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划  
优化过程大致如下：
- 根据搜索条件，找出所有可能使用的索引  
- 计算全表扫描的代价  
- 计算使用不同索引执行查询的代价  
- 对比各种执行方案的代价，找出成本最低的那一个
