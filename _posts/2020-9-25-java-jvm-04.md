---
layout:     post
title:      "细嚼慢咽JVM-04"
subtitle:   "虚拟机执行子系统"
color:      "white"
date:       2020-9-25 23:59:00
author:     "ThreeJin"
header-mask: 0.5
catalog: true
header-img: "https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/wallhaven-76xqre.jpg"

tags:
    - Java
---
> 深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)-读书笔记。

### 前言
&emsp;&emsp;经过前面三个部分的回顾，大体上重新认识了JVM。现在开始针对一些模糊的地方，以书为基础，进行细致的记录。首先是Class文件到底是什么？自己手写的代码被编译器编译之后生成的Class文件长啥样？虚拟机是怎么拿到它？怎么让它跑起来的呢？
#### 一次编译，到处运行（Write Once, Run Anywhere）
&emsp;&emsp;我记得第一次接触Java的时候，就听说Java的跨平台，但是一直不明白为啥能够做到跨平台。其实，所谓的一次编译，到处运行，是因为Java代码写好之后，真正到了执行的时候，其实Java虚拟机是只认Class文件二进制字节流。不同的平台可以看成是不同实现方式的Java虚拟机，大家都会去读由同一份Java代码编译生成的Class字节码，然后再在各自的虚拟机去运行  
&emsp;&emsp;如果以为Java的厉害之处就只是这样的话，那就大错特错了。其实，这个Class字节码文件，不一定是只能靠Java语言才能生成，其他语言也是可以在各自的语言编译器之下生成Class字节码文件的。换句话说，虚拟机也是可以运行除了Java之外的其他语言的（JRuby、Groovy等）
### Class类文件结构
#### 概述
- 是一组以8位字节为基础单位的二进制文件
- 紧凑排列，无分隔符，只有两种数据类型：无符号数和表  
1. 无符号数：属于基本数据类型、u1、u2、u4、u8分别代表1个字节、2个、4个和8个字节，可以用来描述数字、索引引用，数量值或者按照UTF-8编码构成字符串  
2. 表：有多个无符号数或多个表构成的复合数据类型，习惯上是以"\_info"结尾  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/class-style.png)
<center>Class文件格式</center>
- Class的结构中，字段长度、顺序，不允许改变
- 分析工具：JDK的bin目录中的javap或者文本编辑器的十六进制模式
#### 魔数与Class文件版本
- 魔数
1. 是什么：文件的“身份证”，用于识别这个文件是不是虚拟机认识的Class文件，Class文件的魔数：0xCAFEBABE（咖啡宝贝？）  
2. 在哪儿：Class文件的开头4个字节  
- Class文件版本号
紧接着魔数的后4个字节就是Class文件的版本号

#### 常量池（也就是第一篇中讲到的Class常量池）
- 开头
开头是一项u2类型的数据，代表常量池容量计数值（constant_pool_count），起始值为1而不是0 
- 内容
主要存放两大类常量：字面量（文本字符串、声明为final的常量等）和符号引用  
1. 字面量  
文本字符串、八种基本类型的值、被声明为final的常量等  
2. 符号引用  
类和方法的全限定名（可以理解为完整包名将.替换为了/）、字段的名称和描述符、方法的名称和描述符  
&emsp;&emsp;`int a=67`  
&emsp;&emsp;其中67就是字面量，a可以理解为符号引用（狭义理解）。为什么说这样理解符号引用是狭义的，是因为**符号引用，在类加载层面上讨论比较多，源码级别只是一个形式上的讨论。**可以把符号引用看作一个文件的软链接（类似于Linux），当使用这个软连接的时候，才会真正解析它，展开它找到实际的文件。当一个类被加载时，该类所用到的别的类的符号引用都会保存在常量池，实际代码执行的时候，首次遇到某个别的类时，JVM会对常量池的该类的符号引用展开，转为直接引用，这样下次再遇到同样的类型时，JVM就不再解析，而直接使用这个已经被解析过的直接引用  
&emsp;&emsp;相对于全限定名和名称，**描述符主要是用来表征字段的数据类型，方法的参数列表（包含数量、类型以及顺序）和返回值。**规则中，如果基本数据类型（8种）和无返回值的void统一都用一个大写字符来表示，而对象型则用字符“L”加对象的全限定名来表示。（需要注意的是，**Class文件中不会保存各个方法和字段的最终内存布局信息**，到了真正要使用的时候，才会解析并翻译到具体的内存地址中 ）符号引用包含了类和方法的全限定名（可以理解为完整包名将.替换为了/）、字段的名称和描述符、方法的名称和描述符。描述符主要是用来表征字段的数据类型，方法的参数列表（包含数量、类型以及顺序）和返回值，规则中，如果基本数据类型（8种）和无返回值的void统一都用一个大写字符来表示，而对象型则用字符“L”加对象的全限定名来表示  
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/20201016142202.png)
<center>描述符标识字符的含义</center>
举个例子：  
对于数组：每一个纬度都会使用一个前置的“[”来表示，  
`String [][]`
上面的数组会被记录为**[[Ljava/lang/String**  
对于方法，按照先参数列表（按照顺序放在一组“（）”之中），后返回值的顺序进行描述

#### 访问标志（access_flags）
- 是什么：判断Class是类还是接口，是否为public、abstract、final等
- 在哪儿：常量池结束后，紧接着的两个字节

#### 类索引、父类索引与接口索引集合
- 是什么
类索引用于确定类的全限定名，父类索引用于确定这个类父类的全限定名，接口索引用来确定这个类实现了哪些接口
- 有什么
三个按照顺序排列在访问标志的后面，虚拟机根据类索引的u2类型的索引值去找一个类型为Constant_class_info的类描述符常量，再通过这个常量的索引值找到CONSTANT_Utf8_info类型常量中对应的类全限定名字符串

#### 字段表集合
- 是什么
用来描述接口或者类中声明的变量，包含类级别变量以及对象级别的变量，但是不包含方法内部的局部变量
- 有什么
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/20201016143138.png)
<center>字段表的结构</center>
包含字段的作用域（public等修饰符）、类变量or对象变量（static）、可变性（final）、并发可见性（volatile）、可否被序列化（transient）、字段数据类型（基本类型、对象、数组）、字段名称 

#### 方法表集合
![](https://gitee.com/liaoxinyiqiqi/my-blog-images/raw/master/img/20201016144411.png)
<center>方法表的结构</center>
包含访问标志、名称索引、描述符索引以及属性表集合（我们写的方法里面的代码就被编译成字节码指令放在了这个集合的Code属性里，但是不是所有的方法都有Code属性，比如接口或者抽象方法）
#### 属性表集合
也就是在前面字段表和方法表中看到的属性集合，各个属性表不要求具有严格的顺序
